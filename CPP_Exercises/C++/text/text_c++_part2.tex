%#!platex
%%#!jlatex209
%，
% 知能情報工学実験演習 I (2) C++演習 テキスト
% text02a.tex - 04/10/08 版 - 下薗＆乃万
%
%\documentstyle[11pt]{j-article}
\documentstyle[11pt,a4,epsf]{jarticle}
%\usepackage{amssymb}
%\input{a4}
%\setlength{\topmargin}{-1.5cm}
%\setlength{\oddsidemargin}{0cm}
%\setlength{\textwidth}{16cm}
%\setlength{\textheight}{25cm}
%\renewcommand{\@}[1]{{\bf #1}}
\title{{\normalsize 知能情報工学実験演習 II }\\
\bf C++演習 (Part 2)\footnote{2013年度版 下薗，嶋田 作} }
\author{担当: 中村貞吾，下薗真一\\
TA: 石田竹至，蓑代成功\\
\small
e-mail: 
{\sf \{teigo,  t\_ishida, minoshiro \} @dumbo.ai.kyutech.ac.jp},\\
\small
{\sf sin@ai.kyutech.ac.jp}
%\footnotesize
%{\sf t\_inoue@pluto.ai.kyutech.ac.jp}
}
%\date{第1.0.3版 \ 2004 年 10 月}
\date{}
%
% 諸定義
%
\def\linesparpage#1{\baselineskip=\textheight\divide\baselineskip#1}
%%%%% 演習問題の表示 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcounter{execnumber}
\setcounter{execnumber}{0}
\newcommand{\EXERCISE}[1]{
 %\medskip
 \refstepcounter{execnumber}
 \begin{center}
  \fbox{
   \begin{minipage}{\textwidth}
    \noindent
    {\bf 演習 \arabic{execnumber}}
    #1
   \end{minipage}
  }
 \end{center}
 %\medskip
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% ワンポイントの表示 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcounter{pntnumber}
\setcounter{pntnumber}{0}
\newcommand{\POINT}[2]{
 \medskip
 \refstepcounter{pntnumber}
\noindent
■■■■■ {\sf Point \arabic{pntnumber}:} {\bf #1} \hrulefill ■ \\
{\small #2}

\noindent
■ \hrulefill ■■■■■ \\
% \begin{center}
%  \fbox{
%   \begin{minipage}{\textwidth}
%    \noindent
%    {\bf ポイント \arabic{pntnumber} (#1)}
%    #2
%   \end{minipage}
%  }
% \end{center}
 \medskip
}

\setlength{\textwidth}{165mm}       % テキストの幅
\setlength{\textheight}{255mm}      % テキストの高さ
\setlength{\oddsidemargin}{-2mm}     % 偶数ページの左マージン
\setlength{\evensidemargin}{0mm}    % 奇数ページの左マージン
\setlength{\topmargin}{-20mm}         % 上のマージン
%\setlength{\baselineskip}{10.0pt} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% 本文
%
\begin{document}
%\linesparpage{40}
\linesparpage{40}
\maketitle

\medskip

\begin{description}
%\item[期間:] 第 3 年次前期
%\item[機材:] 共通教育研究棟 3 階 S303 室 および S318 室の Linux PC 端末%\\
%	初回のみ 第 I 計算機室(研究棟 6 階)の Linux PC 端末
\item[注意:] \underline{Part 2 では，グループ単位でプログラムを作成し，レポートを作成，提出すること}．
\end{description}

\medskip

\section{グループ演習}
ババ抜きで利用したトランプカードを表す型 \verb+Card+ とカードの集合の実装である \verb+CardSet+ を用いて，トランプ・ゲームの「大富豪（大貧民）」をプレイする環境と思考ルーチンをそなえるプレーヤを作成し，オブジェクト指向言語によるモデル化にもとづくプログラミングとチームでのソフトウェア開発を実践する．

\subsection*{大富豪/大貧民のルール}
大富豪は，ラミーや UNO と同様，場札の上に手札（の組）を捨てていき, 手札をなくしたプレーヤーが勝ちとなるタイプのゲームで, 52枚のカードとジョーカー1枚を使用する．
以下にルールを簡単に説明するが, 作成するプログラムのモデルを確認するために必要な程度にとどめる．  

まず親（ディーラー）は，カードをよくシャフルして，すべてのカードを大富豪から時計回りに一枚ずつ各プレーヤーに配る．
配り終えたら，ゲームを親のターンから開始する．
ターンが回ってきたプレーヤーは，手札から同じランクのカードを一枚以上，ジョーカーを含め四枚まで組として場に出せる．
このカードの組をリードという．
ただし，既に場に他人の出したリードがある場合は，同じ枚数のより強いランクの札の組でなければ出すことはできない．リードがペア, 3カード，あるいは 4 カードならば，次のプレイヤーは同じ枚数でより強いカードの組を出さねばならない．
出せない，出したくない場合は, 場に札を出さずにパスすることができる．
場にカードを出すか，パスすればそのプレーヤーのターンは終了である. 
ランクはジョーカーが最も強く, 続いて $2 > \mathrm{A} > \mathrm{K} > \mathrm{Q} > \mathrm{J} > 10 > \cdots > 3$ の順となる. 
全員がパスをつづけ，リードを出したプレーヤーにターンが回ってきた場合，リードは流れたとして，最後にカードを出した，つまりリードを出したプレイヤーがリーダーとなる．
リーダーは，自由にリードとなる札（の組）を選んで出すことができる．

最初に手札をなくしたプレーヤーが大富豪，つまり１位となる．
残るプレーヤーも勝ち抜けるまでゲームをつづけ，全員の順位を決める．

その他にも大富豪には多くのルールがバリエーションとして存在する．
ただし，今回の演習では時間にも限りがあるため，
（１） ジョーカーや 2 を最後の札としてあがってもよいこととし，
（２） シークエンス\footnote{同じスーツで3枚以上の連続する数字}や
（３） 革命\footnote{4カードを出した場合は，強さが逆転する．すなわち，強さが3＞4＞....の順となる．}，
（４）大富豪と大貧民の間のカードの交換（搾取）と，都落ちのルールは，使用しないものとする．

\subsection*{プログラミングのためのモデル}
プログラミングを行う場合，特にオブジェクト指向言語では，プログラミングする対象を，担う機能や使用する資源にしたがって独立した部分や部品，単位にわけてデータ型（クラス）を作らなければならない．
その場合，現実のものにあわせて，あるいは似せて作るのが最も効率的である．

今回，大富豪ゲームを複数プレーヤーが行う状況をプログラムにするにあたっては，
次のような考え方で作ることにする：

（１）ディーラーは，プレーヤーの一人（大貧民）が兼ねるのではなく，プレーヤーたちとは独立した，ゲームをルールどおりに進行させる役割を担うものと考える\footnote{実際のカードゲームにおけるディーラーは，大貧民もしくはほかの誰かが行うが，このモデルではゲーム管理を行うクラスであり，実際にプレイするプレイヤーではないことに注意．}．

すなわち，札を配るだけでなく，ターンなどルールに従った行動をプレーヤーに対してうながす，またプレーヤーが出した札がリードとして通るかどうかを確認し，また他のプレーヤに確認させる，などコミュニケーションを司る役割を負う．
ゲームに参加するプレーヤーとその順位の管理も行う．
つまり，ディーラーは万能で完全に公平な立場をとるゲームの管理人である．

（２）プレイヤーは，それぞれがターンの回ってくる参加者である．
人間がカードゲームをする場合とは異なり，プログラムにはあらかじめカードを識別する能力はなく，大富豪をするためのテーブルもない．
そこで，カードのやりとり全てをディーラーに任せたものを考える．
プレーヤーは，「カードの出し入れだけができる引き出しがついた箱（に入っている人）」と考えればよいだろう．
プレーヤーのターンがまわってくる順番は，ディーラーがどの箱の引き出しをさわるかで決まる．
カードの配布は，ディーラーが引き出しにカードを入れることで行われる．
ディーラーはターンがきたプレーヤーの引き出しにリードを入れ，札を出すかパスするかを促す．
引き出しにリードとより強い組が入っていたら，新たなリードとして受け入れ，他のプレーヤーの引き出しに入れて見せる．
そうでなければ，リードを取り出し，その他のカードはそのままにして引き出しを押し返す．
そして，プレーヤーの手札がなくなったら，勝ち抜けを記録し，次のゲームでの順番とするのである．

人間同士でゲームをする場合，これらの「コミュニケーション手順」は言葉や視覚によって暗黙のうちに完成する．
しかし，機械的なゲームの進行を実現するには，これらの作業を明確にしなければならない．
プレーヤーが人であっても，機械であっても，たとえばネットワーク対戦を考えれば，その必要性が容易に理解できるだろう．


\subsection*{サンプルプログラム}
ゲームを行う環境をつくるためのプログラム，\verb+Dealer.h+ および \verb+Dealer.cpp+ ，\verb+main.cpp+ は, 変更を加えずにそのまま使用する．
グループで作成するのは，プレーヤーをシミュレートするクラス \verb+Player+ に関する部分のみである．

サンプルプログラムとして，\verb+Player.h+ および \verb+Player.cpp+が用意した．
このクラスのデータ構造や手続きを拡張，整備して，より強いプレーヤーを作るのが目的である．
クラス継承のしくみを使えば，\verb+Player+ クラスを継承した別のプレーヤー用クラスを作り，新たに必要な変数と関数の作成もしくは変更だけを行えば，そのまま既存の \verb+Dealer+ クラスとともに使用できる．

プレイヤーが，ターンにおいてどのカードを出すかは \verb+Player::follow()+ によって決定される．
サンプルプログラムにおいては，
\begin{quote}
\linesparpage{50}
\begin{verbatim}
void Player::follow(const CardSet & tbl, CardSet & s) {
    Card tmp;
    s.makeempty();
    hand.pickup(&tmp, -1) );
    s.insert(tmp);
    return;
}
\end{verbatim}
\end{quote}
となっている．\verb+Player::follow()+ は引数として場のカードと自分のカードが定義されているが，サンプルプログラムでは，場のカードについては考慮せず，自分の手持ちのカードセットからランダムに1枚引き抜くという最もナイーブな戦略に基づいている．

また，現在は何も行っていないが，自分の番以外の時に他人が場に捨てたカードセットなどの状況を確認する関数として \verb+Player::approve()+ というものも考える．
 
実際の実装で考えなければならないのは，この2つの関数のみである．
プレイヤーが出したカードが現在の場に出ているカードと比較して受理できるかなどの判定は， \verb+Dealer+ が行うので考えなくて良い\footnote{ゲームとしての判定は \verb+Dealer+ が行うが，実際問題としては，場に出そうとしているカードが通るのかを \verb+Player+ も判定した方が良い．それを考慮せず，通らないカードを出してしまうと，パスしたという扱いになり，不利になる．}．
また，パスをしたい場合は，空のセットもしくは通らないカード(現在，場に出ているカードよりも弱いカード)を \verb+follow()+ に渡せばよい．
その場合，通らないカードセットは自動的に手持ち札に戻される．
 
\EXERCISE{
\verb+Player::follow()+ と必要であれば \verb+Player::approve()+ を改良し，より知的な戦略に基づく Player を実現せよ． 
}
\section*{演習を進める上での注意}
演習に際しては，リーダーを中心にグループ内で事前に役割分担を決め，プログラムを作成すること．
演習では，まず，何らかの戦略に基づくプレイヤーを複数実装する．
例えば，現在は1枚しか出せないが，複数のカード(ペアや3カードなど)を出せるようにしたり，選んだカードが場に通るかどうかを判定して出すなどが考えられる．
それぞれを対戦させたり，考察することで，より洗練されたプレイヤーに改良するプロセスを繰り返していく．

基本的に \verb+Player::follow()+ と \verb+Player::approve()+ 以外の関数を変更しないこと．
この2つの関数を拡張する場合，使用して良いのは \verb+Card+ と  \verb+CardSet+ のメンバ関数である\footnote{他の班と対戦する際に，改良した \verb+Player::follow()+ と \verb+Player::approve()+ をコピーすれば動作するように心がけて作ること． \verb+Player+ 内に必要に応じて新しい関数を作っても良いが，あくまで， 他のクラスや \verb+Player+ 内に既に定義されているメンバ関数などに影響しないようにすること．}．
複数のプレイヤーを実装する方法はいくつか考えられるが，
継承によりサブクラスを作成すること．
そのためのサンプルとして，\verb+LittleThinkPlayer+を用意している．
最終的には，各班の名前で新たなサブクラス（例えば1班なら，\verb+Group1+）を作成すること．
%本演習では，\verb+Player::follow()+ 内で，現在カードを出そうとしているプレイヤーの名前 \verb+name+ で判別するのが最も簡単である．
\begin{quote}
\linesparpage{50}
\begin{verbatim}
class LittleThinkPlayer : public Player {
// LittleThinkPlayer は Player のサブクラス(派生クラス)
　　CardSet memory;
public:
　　LittleThinkPlayer(const char *);
　　bool follow(CardSet &, CardSet &);
　　bool approve(CardSet &, int[]);
};
\end{verbatim}
\end{quote}
この方法に基づき，戦略ごとに適当なサブクラスを定義すればよい．そして，\verb+main+関数で，以下のように使い分ければよい．
\begin{quote}
\linesparpage{50}
\begin{verbatim}
d.regist(new Player(“Erika”)); 　
　// Player.cpp の follow() や approve() 
d.regist(new LittleThinkPlayer("Warabi")); 
　// LittleThinkPlayer.cpp の follow() や approve() 
\end{verbatim}
\end{quote}
%void Player::follow(const CardSet & tbl, CardSet & s) {
%    ....
%    if (name == "Konomi") { /* プレイヤー名 Konomi の戦略 */}
%    if (name == "Takenoko") { /* プレイヤー名 Takenoko の戦略 */}
%    ....
%}

実験の最後の時間に各班で作成した思考ルーチンを対戦させる．
具体的には，ランダムに割り振られた予選リーグを行い，各予選リーグで1位の班で決勝リーグを構成する．
この順位は最終的な成績に加点される．

\section{レポートについて}
レポートは以下の書式・期日で各班ごとに1つ提出すること．
\begin{enumerate}
 \item A4 のレポート用紙を用い，上部をステープラでとめること．\vspace*{-0.5em}
 \item 表紙には，演習名 (知能情報工学実験演習 II\ C++演習：グループ演習)，班員の学生番号と名前，提出日を明記すること．\vspace*{-0.5em}
 \item 各班員の役割分担 (例えば，各繰り返しの段階で実装した戦略や作業などを箇条書きする程度でよい\footnote{ただし，「みんなで頑張った．」などの抽象的な記述ではなく，誰が何を担当したか具体的に書くこと．最終的に採用されなかった戦略などもこの中に加えて良い．})\vspace*{-0.5em}
 \item プログラムリスト (ただし，最終的に実装した部分のみでよい)\vspace*{-0.5em}
 \item 実装した戦略ルーチンの考え方 (工夫した点および不完全な点を含む)\vspace*{-0.5em}
 \item 実行結果 (主要な部分・レポートでの説明に必要な部分のみでよい)\vspace*{-0.5em}
 \item 全体の考察\footnote{感想ではなく考察をすること．「面白かった．」や「難しかった．」だけではダメ．}とまとめ\vspace*{-0.5em}
 \end{enumerate}
レポートは，このテーマの実験最終授業日の翌週の同一曜日までに，研究棟 6 階のレポートボックスに提出すること．
レポートは評価され，不備のあるものは〆切から1週間以内に知能の掲示板に再レポートの掲示をするので，注意しておくこと．

%班ごとのレポートとは別に，個人単位でA4サイズ1枚の個人評価票(書式指定)も提出すること．
\end{document}

\begin{quote}
\linesparpage{50}
\begin{verbatim}

\end{verbatim}
\end{quote}

\begin{quote}
\linesparpage{50}
\begin{verbatim}

\end{verbatim}
\end{quote}

\begin{quote}
\linesparpage{50}
\begin{verbatim}

\end{verbatim}
\end{quote}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%###########%%%


\EXERCISE{

1セットのトランプのカード(これをデッキという)でゲームすることを考える．
ここでは，1デッキには1枚のジョーカーを含む53枚のカードがあるとする．

1デッキ内のカードの部分集合を表す型
(これは1人のプレーヤーの手持ちのカードの集合や捨てカードの集合を表す)
を作れ．

}

\begin{enumerate}

 \item[(1)] カード1枚を表すデータ型を作る(作り方いろいろ)．

 \item[(2)] カードの集合(手持ちのカード)を表す型を作る．
(ただし，使用しているカードは1組とする．(同じカードは1枚しかない．)
(下薗先生案をちょっと変更．
実現方法いろいろ: 配列，線形リスト，ビット表現，木...
それぞれどんな長所短所があるかを考えさせる)

\end{enumerate}

\POINT{ポインタとポインタ引数の説明}{}

\POINT{ヒープとスタックの説明}{}

\section{C++言語で型を作る}

\subsection{C言語には抽象データ型を作りにくいところがある}

＃下薗先生の説明

\subsection{演習3}

\begin{enumerate}

 \item[(1)] 演習1の分数の型をクラスを使って書きかえよ．

\end{enumerate}

\subsection{演習4}

\begin{enumerate}

 \item[(1)] 演習2のカードの集合を表す型をクラスにせよ．
主プログラムを作り確認せよ．

 \item[(2)] 演習2のカードの集合を表すクラスの実現を変えよ．
同じ主プログラムで動くか．動かないとしたら何が原因か．

\end{enumerate}

\section{クラスをもとにより大きなクラスを作る}

\subsection{クラスのメンバ変数にクラスを含めればより大きいクラスが作れる}

分数の実数部，仮数部を持つ虚数クラスの実現

\subsection{演習5}

\begin{enumerate}

 \item[(1)] 虚数クラスを完成させなさい．

\end{enumerate}

\subsection{演習6}

\begin{enumerate}

 \item[(1)] 演習4のカードの集合クラスを用いて，
「ババ抜き」の全プレーヤの状態を表すクラスを作りなさい．
(どんな操作が必要か?)

\end{enumerate}

\section{習うより慣れろ}

\subsection{演習6}

\begin{enumerate}

 \item[(1)] 自分の好きな(カード?)ゲームの状態を表すクラスを作りなさい．
適当な主プログラムを作り，(少なくとも)電子ゲーム盤を作りなさい．
余力のある人は，簡単な思考ルーチンを作ってもよい．

\end{enumerate}

\section{ここで扱っていない大事なこと}

\begin{itemize}

 \item 型の間の関係の表し方(1対1，1対多，多対多)

 \item クラスの継承

 \item 演算子の再定義

 \item ...

\end{itemize}

\end{document}


・型とは何か

・抽象データ型

・データ構造は型の実現方法である

・問題に対していきなりベタで変数を書くのではない．
問題の規模に応じた(十分大きな，処理が書き易い)型を作るのが先決．

・型を実現するのに必要なことは，(1)一つのデータを一つにまとめる，(2)一つのデータをまとめて操作できること．

・一つのデータを一つにまとめるには，(Cでは)構造体を用いる．

・ヒープとスタック
・ポインタとポインタ引数

Cでの演習 (card)

・まとめて操作させる上で，Cの構造体は不便である

・情報隠蔽とポリモルフィズムの必要性

C++の説明と演習 (card)

・型を組み合わせてより大きな型を作る

・1対1

・1対多

・多対多

・冗長なデータはまとめてポインタで指す

\end{document}

「文書は人のためならず」という．

