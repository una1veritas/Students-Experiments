%#!platex
%%#!jlatex209
%
% 知能情報工学実験演習 I (2) C++演習 テキスト
% text02a.tex - 04/10/08 版 - 下薗＆乃万
%
%\documentstyle[11pt]{j-article}
\documentclass[11pt,a4,epsf]{jarticle}
%\usepackage{otf}
\usepackage{amssymb}
\usepackage{theorem}
\usepackage[titletoc,title]{appendix}
%\input{A4}
\setlength{\topmargin}{-1cm}
\setlength{\oddsidemargin}{0cm}
\setlength{\textwidth}{16cm}
\setlength{\textheight}{24cm}
\renewcommand{\@}[1]{{\bf #1}}
\title{{\normalsize 知能情報工学実験演習 II } \\
{\bf C++演習 (Part 1)}
}
\author{担当: 中村貞吾，下薗真一\\
TA: 石田竹至，蓑代成功\\
\small
e-mail: 
{\sf \{teigo,  t\_ishida, minoshiro \} @dumbo.ai.kyutech.ac.jp},\\
\small
{\sf sin@ai.kyutech.ac.jp}
%\footnotesize
%{\sf t\_inoue@pluto.ai.kyutech.ac.jp}
}
\date{Apr. 2015}
%\date{}
%
% 諸定義
%
\def\linesparpage#1{\baselineskip=\textheight\divide\baselineskip#1}
\newtheorem{exerc}{演習}
\newtheorem{adv}{発展課題}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% ワンポイントの表示 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcounter{pntnumber}
\setcounter{pntnumber}{0}
\newcommand{\POINT}[2]{
 \medskip
 \refstepcounter{pntnumber}
\noindent
■■■■■ {\sf Point \arabic{pntnumber}:} {\bf #1} \hrulefill ■ \\
{\small #2}

\noindent
■ \hrulefill ■■■■■ \\
% \begin{center}
%  \fbox{
%   \begin{minipage}{\textwidth}
%    \noindent
%    {\bf ポイント \arabic{pntnumber} (#1)}
%    #2
%   \end{minipage}
%  }
% \end{center}
 \medskip
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% 本文
%
\begin{document}
%\linesparpage{40}
\linesparpage{36}
\maketitle

\medskip

\begin{description}
\item[期間:] 第 3 年次前期
\item[機材:] CAD実験室(共通教育研究棟 3 階 S303 室)の Linux PC 端末%\\
%	初回のみ 第 I 計算機室(研究棟 6 階)の Linux PC 端末
\item[注意:] この実験・演習は第一部 Part 1 と第二部 Part 2 をそれぞれ 3 回，合計 6 回で行う．
関連科目の復習ほか事前学習を十分行ったうえでのぞむこと．
事前学習が不十分で時間が不足となった場合は，自宅等のＰＣや本実験・演習を行う計算機，その他研究棟側の端末などを活用することで補うこと．\\
なお，\underline{Part 1 の演習は個人単位で行ない，各自報告書を作成，提出すること}．
\end{description}

\medskip

\section{はじめに（演習の目標）}

C 言語および C++ 言語を使った実用的なプログラムに必要なプログラミング作法，
つまり読みやすくミスの生じにくいプログラムの書き方を身につける．
その中で，構造化プログラミングと，その発展形であるオブジェクト指向プログラミングの一部の理解を深め，活用できるようになることを目標とする．

まず簡単に，「プログラミング演習の課題をこなすためのプログラミング」から脱却するうえで有効な指針を挙げておく．

\subsection{同じことなら単純なものほどよい（オッカムの剃刃）}

プログラムを書くとき，あまり深く考えず，とりあえず必要そうな変数を
山のように宣言するのをよく見かける．
意味のわからない名前の変数や関数，使われない変数や引数がそのまま残っている．
もし自分がそうなら，すぐやめること．

プログラムを書くのは，盛り込まれる規則，知識，アイディアを，共同開発者や利用者など，未来の自分自身をふくむ多くの人と共有し，活用するためである．
そのためには，客観的な基準で整理整頓されている必要があり，
これを実現する最も有効な方法は，単純で簡潔にすることなのである．

\subsection{まず``データ型''を作る}

整数型や文字型，つまりバイトやワードなどCPUが直接操作できる型だけで実用的なプログラムを作ることは，ハードウェアを意識せざるをえない組み込みマイコンのプログラムなどを除けば，めったにない．
たいていは，人間にとって意味のあるデータの単位をプログラムで扱う「型」として表現することからはじめることになる．
実はこの作業が，プログラムを単純で簡潔にするための鍵であり，最終的にプログラムを作成することで解決しようとしている問題の解決の鍵である．

C/C++ では，構造体もしくはクラスというデータ型でデータ構造をメモリのバイトやビットの単位で定義でき，さらにその操作を関数に対応させてプログラムを書くことができる．
この特徴を生かしてこそ言語の価値があるといえる．

%\footnotetext{
%Niklaus Wirth（著名な計算機科学者．チューリング賞受賞者）の名著(の一つ)に「アルゴリズム+データ構造=プログラム」という本がある．
%操作とその対象は，常に対応させて考えなければならない．
%データ型をうまく実現する際にデータ構造を考える必要がある．
%Wirth の書名は今でも意味がある．}


\subsection{大域変数は禁止}

大域変数はいつでもどこででも使え，引数に書かなくても関数の間でデータ受け渡しができる
ので即席プログラムには便利である．
しかし，プログラムが大きく複雑になると，変数がどこでなんのため使われているかわからなくなる．
とりわけ，オブジェクト指向プログラミングでは``大域変数を使いたい病''は大きな障害になる．

データを型として組み合わせてまとめること，使う変数を最少限にすることが，
プログラムをうまく作るコツである．
関数のデータのやり取りも，操作対象や動作を単純で明快なものにするため，引数と返り値のみで行うべきである．



\section{C言語での型づくり（復習）}

\subsection{データ型は，一定の意味を持たせたモデルと操作の組合せ} %である}

デジタル機器では，どんなデータもビットの列で表す．
例えば，整数\verb+1040187392+と実数\verb+0.125F+はどちらも 32 ビットの列 
\[
\verb+0011 1110 0000 0000 0000 0000 0000 0000+ \:\: (\verb+3E 00 00 00+)
\]
である．
これはさらに，長さ 2 の文字列であるかもしれないし，音楽 CD に
記録されたステレオ音声データの 1 サンプル目かもしれない．
計算機のハードウェアは，どのアドレスのデータが何型かといった情報を持つための機構を用意していない．
% C 言語の \verb$union$ 共用体を使えば，メモリ上の同じバイト列を異なるデータ型によみかえる
%ことをプログラム中で正しく意図的に行うことができる．
%
我々がプログラムの中で代入や演算をさまざまなデータ型に対して使用できるのは，
\verb+int+型の変数やデータには\verb+int+型の操作 (命令) を，
\verb+float+型の変数やデータには\verb+float+型の操作を，
変数やデータの型にあわせてコンパイラが選んでいるからである．
%つまり，データの意味と型は操作で決まる．

データ型の本質は，内部表現の方法ではなく，
{\bf モデル}(例えば数学でいう「整数」)と
{\bf 操作}(例えば整数の加算演算)の対応関係にある．
実際に，\verb+int+型や\verb+float+型がメモリの中でどのように表されるかを知らなくても，我々はプログラムを書ける．
%\footnote{ふつうは
%自分が使っている計算機がbig-endianかlittle-endianかすら気にしない．}．
データ型がどんな内部表現か知らなくても（普通は知らない），操作がその内部表現に対応していれば正しく動作するのだ．

C 言語のプログラムでは，対応づけは整数型（言語仕様で定義された型）に対してはコンパイラが行い，それ以外の型についてはプログラマが管理する．
なお C++ では，さらに構造体／クラスなどプログラマが定義したデータ型と関数を対応させて書けるようになっている．
%この対応をプログラマが記述できるようにして，\verb$+ - * /$ など CPU が直接行える演算と見かけが同じように使えるようにするためである．

%演習１


\subsection{計算機中に存在しないものを表す} %のが抽象データ型}

プログラムで必要となるデータ型には様々なものがありうるので，言語であらかじめそのすべてを用意することはできない．
整数や浮動小数点数ですら，桁や精度の制限があり，数学的な整数や実数が表されているわけではない．
必要なデータ型は，すでに使えるようになっている型を組み合わせて{\bf 自分で作るもの}なのである．
これは{\bf 抽象データ型}とよばれる．

自分で型を作るとき，以下の二つが重要である．
\begin{enumerate}

 \item[(1)] データ一個を表すのに必要なデータ（値）は，すべて一つにまとめる．	\\
例えば，浮動小数点数では符号部と指数部と仮数部を一まとまりにして扱っている．
一つなのであれば，別々にならないようにする．

 \item[(2)] 一個のデータは，いつもまとめて操作する．	\\
例えば，浮動小数点数の演算をすると，符号部も指数部も仮数部も一緒に使われ計算が行われる．
その一部だけを操作して整合性が失われるようなことがないようにする．

\end{enumerate}
なぜなら，人間にとって，一つと考えられるものは「一つ」として扱えるほうが楽で，わかりやすく，間違いがないからである．

\subsection{構造体でデータを一まとめにする}

一まとめにするには，必要なデータを組み合わせる．
この目的のために，C言語では，主に構造体 (struct) を宣言することになる．
(C++言語では，構造体をクラス class ともよぶ．)
組み合わせに使うデータの型が言語で用意されたものか，定義ずみの抽象データ型かは，問われない．

例えば，数学でいう$\mathbb{R}^2$の要素，2次元ベクトル（のようなもの）を表すには，
それぞれの成分を例えば \verb+double+ 型で表すことにして
次のような構造体 \verb+vector2+ を作ればよい．
\begin{quote}
\linesparpage{50}
\begin{verbatim}
struct vector2 {
        double x, y;       /* それぞれ x 成分，y 成分 */
};
\end{verbatim}
\end{quote}
また \verb!double val[2];! のようにして，x, y の各値を配列の要素で表すこともできる．


\subsection{データの操作は一まとめで行なえるようにする}

データ型を作ったら，その中身を気にすることなく扱えるよう，操作を準備する．
その型のデータそのものが，もともと言語にあるかのように扱う関数
を定義する．
そうすることにより，後で型の定義を変更することになったとしても --- これは実際によく起きるが --- 操作関数だけを変更すればよい．

例えば，2次元ベクトルの加法演算は，
\begin{quote}
\linesparpage{50}
\begin{verbatim}
struct vector2 addv2(struct vector2 u, struct vector2 v)
{
        struct vector2 ret;

        ret.x = u.x + v.x;
        ret.y = u.y + v.y;

        return ret;
}
\end{verbatim}
\end{quote}
と用意し，プログラムで 2次元ベクトル同士の加算が必要なら，
\begin{quote}
\linesparpage{50}
\begin{verbatim}
vec0 = addv2(vec1, vec2);
\end{verbatim}
\end{quote}
などと書く．
このとき，関数の名前は対象となる型の名前と操作の名前を組み合わせるなどしてつけるが，そのルールはプログラマが考え，管理する．
操作関数を作る手間を惜しんで，いちいち
\begin{quote}
\linesparpage{50}
\begin{verbatim}
vec0.x = vec1.x + vec2.x;
vec0.y = vec1.y + vec2.y;
\end{verbatim}
\end{quote}
などと書いていれば，実用的なプログラムでは，加算は何度も行うはずなのでかえって手間になるし，なにより何をしたいのかが一見してわからない．
コピー＆ペースト後の変数名の変更し忘れがおき，不幸になることが確実である．

\subsection{抽象データ型は関数の作り方の指針} %でもある}

関数の宣言方法はわかっていても，
なにを関数にすればよいのかわからなかったかもしれない．
抽象データ型の考えにもとづけば，{\bf あるデータ型をあつかう関数は，その型のデータの操作として意味のある関数にする}
という，関数の作成指針が明確になる．

プログラムを作る際は，定義されている小さな型から，大きな型を作っていく．
関数も，データに必要な操作ごとに，小さな型のための関数を組み合わせて大きな型のための関数を作ってゆく．
こうすることで抽象度の高いレベルで処理を簡潔に記述でき，
自然ときれいな ------ つまり読みやすくミスの起きにくい ------
プログラムが書ける．

\subsection{演習課題}
\begin{exerc}%\EXERCISE{
C言語による2次元ベクトル型のソースファイルが
\verb+vector2c.h+ および \verb+vector2c.c+ として，
またそれを使った簡単なプログラムが \verb+vec2ex1c.c+ として，
それぞれ用意されている．
以下を行い，確認せよ．

\begin{enumerate}
\item[(1)] プログラムのコンパイルし，動作させよ．
\item[(2)] ベクトルの減算の関数を \verb+vector2c.h+ および \verb+vector2c.c+ に作成追加し，また，\verb+vec2ex1c.c+ の主プログラムに減算を追加し，
正しく動くことを確かめよ．

%%% 検討: 内積の関数
%%% 検討: 引数をポインタ型に変える演習

\end{enumerate}

\end{exerc} %}

%演習３

\newpage
\section{C++言語で型を作る}

\subsection{C言語での型作りの弱点}

C言語で抽象データ型を作ることはできるが，
ソースコードがもっと複雑で大規模になった場合,
複数のプログラマで分担して作業するような場合に，
次のような問題や不都合が生じる．

\begin{enumerate}
 \item[(1)] 
構造体のメンバ変数にはどのような状況でも直接アクセスができ変更できるが，意識せずその一部を変更した場合には，意図しないことが起きうる．
プログラマの心がけに任せるばかりでなく，
むしろ積極的に，たとえば \verb+vector2+ をベクトルとして利用する部分では
\begin{quote}
\linesparpage{50}
\begin{verbatim}
vec0.x = vec1.x + 2 * vec2.x;
\end{verbatim}
\end{quote}
のような，意味がはっきりしないメンバ変数の操作はできないようにしたい．
 \item[(2)] 
加算には，2次元ベクトルの加算だけでなく，3次元ベクトルや行列の加算もある．
それらは「加算」という意味では同じであるが，引数の型が異なるため\verb+addv2+，\verb+addv3+，
\verb+addmatrix+ のようにそれぞれ別の関数名を付ける必要がある．
命名法の管理と利用が煩わしい．
\item[(3)] 
変数の宣言や動的割り付けを行った直後，その変数の各メンバ変数の値がどうなっているのか，あるいはどうする必要があるのかはプログラムコードからははっきりしない．
それぞれの初期値が 0 や \verb+NULL+ なのか，それ以外なのか，あるいは不定なのかは，コンパイラやOS に依存する．
メンバ変数に抽象データ型が使用され，入れ子になっている場合，どこまで初期値の面倒をみれば
いいのかも不明である．
\end{enumerate}


\subsection{C++言語ではクラスによって型作りが楽になる}

C++ では，こののような問題を解決するために{\bf クラス}というデータ型定義
の機構が提供されている．
クラス \verb+class+ は，C言語の構造体 \verb+struct+ を拡張したもので，「データを一まとめにする」機能に加え，
初期化や操作，アクセスなどそのデータに必要な関数も一まとめにすることができ，またそのデータの内部，つまりメンバ変数や関数へ外からアクセスできるかどうかの制御もできる
\footnote{ C++ では構造体 {\tt struct} も関数を持てるよう拡張されており，{\tt class} と {\tt struct} の違いは，デフォルトが private か public か，というだけである．}．
これは{\bf データと手続きのカプセル化 encapsulation}と呼ばれ，
オブジェクト指向プログラミングでの考え方の一つである．
また，変数の宣言や動的領域の確保など，新たにデータ領域が用意される時，明示しなければデフォルトの初期化関数が自動的に呼び出される．
また引数を与えて初期化することもできる．
必要な初期化は必ず行われるよう保証できるのである．
これも，オブジェクト指向プログラミングでの考え方の一つである．

2次元ベクトル型をクラスで表現すると，たとえば以下のようになる．
\begin{quote}
\linesparpage{50}
\begin{verbatim}
class Vector2 {
// メンバ変数
private: // 隠す
        double x;       // x値
        double y;       // y値

// メンバ関数
public: // 隠さない／隠せない
        Vector2(void)   { }
                // デフォルトコンストラクタ(初期値不定)
        Vector2(double x0, double y0);
                // x0, y0 を与えて定数 (x0, y0) を得るコンストラクタ
        Vector2 add(Vector2 u);
                // 自身のベクトルとベクトル u との和を求める
        ....
};
\end{verbatim}
\end{quote}
このように，メンバ変数と同様に，その型専用の関数も記述できる．

クラスでのメンバ変数の宣言は，構造体での宣言と同じである．
ただし，アクセス指定子 \verb+private:+ によって，メンバ変数 \verb+x+と
\verb+y+ をこのクラスのメンバ関数 (後述) だけがアクセスできる
「プライベート (私的) な」変数とすることができる．
これにより，メンバ変数を意識せず ------ 
つまりクラスの定義以外の場所で ------ 変更するプログラムは，コンパイルエラーとなる!

データのクラスにそなわるメンバ関数を呼び出すときは，構造体のメンバ変数を参照するときと同様に，変数に \verb+.+ で結び付けた形で記述する．
例えば，
\begin{quote}
\linesparpage{50}
\begin{verbatim}
Vector2 v1, v2, v3;
...
v3 = v1.add(v2);
\end{verbatim}
\end{quote}
という形で呼び出す．
これは，C言語の場合には，
\begin{quote}
\linesparpage{50}
\begin{verbatim}
v3 = addv2(v1, v2);
\end{verbatim}
\end{quote}
のように書いていたプログラムに相当する．
クラス型に備えられた関数は，その第一引数は，つねにクラス型データが第一引数となる．

クラス内で宣言したメンバ関数の実体は，例えば次のようにプログラムする．
\begin{quote}
\linesparpage{50}
\begin{verbatim}
Vector2 Vector2::add(Vector2 u)
{
        Vector2 ret;

        ret.x = x + u.x;
        ret.y = y + u.y;

        return ret;
}
\end{verbatim}
\end{quote}
ここで，ただの \verb+x+ と \verb+y+ は
%\footnote{実際には「このデータ (オブジェクト)」のポインタを表す \verb+this+ を使って \verb+this->x+ と \verb+this->y+
% と書くところで，\verb+this+ が省略されている．}
 \verb+add+ 関数を呼び出した（作用する）変数のメンバ変数，つ
まり \verb+v1.add(v2)+ では \verb+v1+ のメンバ変数 \verb+v1.x+,
\verb+v1.y+ を指す．

上の例では，メンバ関数はアクセス指定子 \verb+public:+ によって外部から使
うことができる「公開された」関数になっている．
メンバ変数，メンバ関数は，
それぞれ \verb+private:+ (そのクラス以外からはアクセス不可能)，
あるいは \verb+public:+ (そのクラス以外からもアクセス可能) にできる．
メンバ変数を \verb+private:+ に，
メンバ関数を \verb+public:+ にするのが典型的である．


\subsection{C++言語では変数の初期化を明示的に記述する}

クラス名と同じ関数名のメンバ関数は，{\bf コンストラクタ}と呼ぶ．
コンストラクタはそのクラス（型）の変数の場所をメモリ上に確保するときに呼び出され，その変数が持つメンバ変数の値を設定する．
その返り値はそのクラス型のデータ (オブジェクト) と決まっており，型は記述しない．

変数の初期化し忘れを防ぐために，コンストラクタは必ず呼び出されることになっ
ている．
コンストラクタは引数を持つこともでき，初期値を引数で指定したり，他の型のデータを初期化に使うものも作成できる．
引数の無いコンストラクタは初期値を与えない変数宣言などで暗黙のうちに呼び出されるので，特に {\bf デフォルトコンストラクタ} と呼ばれる．

コンストラクタは，変数宣言などでプログラマが意識して呼び出す場合のほかに，
代入 \verb+=+ や型変換 (type cast) で気づかないうちに呼び出される場合もあり，プログラムのミスの原因になることがある\footnote{Smalltalk (Squeak) や Java などの言語ではクラス型データはポインタなど
間接参照なのであまり目立たないが，C/C++ ではもともと構造体の代入や関数の引数で値参照が可能なので，注意が必要である．}．
代入やコピーで呼び出されるコンストラクタは{\bf コピーコンストラクタ}とよばれ，
引数は (\verb+const+指定された) 同じクラスのデータへの参照 \verb+&+ 一つのみである．
C++ プログラミングでのミスを減らすには，自分で作るクラスにはデフォルトコ
ンストラクタ，コピーコンストラクタはとりあえず作っておく習慣をつけるとよい．

この \verb+&+ 演算子は，C 言語ではポインタが指すアドレス（ポインタ型変数のもつ値）を変数から作るために使うが，
C++ 言語では，さらに関数の引数で「型名 \verb+&+ 変数名」のように使うことができる．
これは，ポインタ型を介さずに，コピーではなく元の変数を参照するという意味である．

\begin{exerc} %\EXERCISE{
(C++言語による) 2次元ベクトル型のソースファイルが，
\verb+vector2.h+および\verb+vector2.cpp+として，
またそれを使った簡単な主プログラムが\verb+vec2ex2.cpp+として，
それぞれ用意されている．以下の演習を実施せよ．

\begin{enumerate}

\item[(1)] プログラムをコンパイルし，実際に動くことを確かめよ．

\item[(2)] クラス \verb+Vector2+ の減算のメンバ関数を
\verb+vector2p.h+ および \verb+vector2.cpp+ に宣言追加し，
また，\verb+vec2ex2.cpp+ の主プログラムに減算のテストを追加し，
減算が行われることを確かめよ．

%%% 検討: 内積の関数
%%% 検討: 引数をポインタ型に変える演習

\end{enumerate}
\end{exerc} %}

\begin{adv}
C++ 言語では，\verb+add+ など二項演算を行う関数を，自然な二項演算子 \verb=+= で使えるようにプログラミングできる．

興味があれば，どのようにすればそのように定義できるか，また他にどのような二項演算子をプログラマが定義できるか，調べてみよ．
\end{adv}

\begin{exerc} %\EXERCISE{
コンストラクタが明示的に，また暗黙の内に選択的に呼び出されることを以下の
方法で確かめよ．
\begin{enumerate}
\item[(1)] 
デフォルトコンストラクタ \verb+Vector2(void)+ で，\verb+x+ と \verb+y+
に初期値 \verb+0+ がセットされるよう変更し，\verb+printf+ 等で変数宣言な
	   どの直後に初期化されているかどうかを確かめよ．
\item[(2)] 
デフォルトコンストラクタと，コンストラクタ
\verb+Vector2(double, double)+ の中で \verb+printf+ 等でメッセージや値の表示出力を行うようにして，適切にコンストラクタが呼び出されているか確認をせよ．
\item[(3)]
値のセットされた \verb+Vector2+ 型オブジェクトと全く同じ \verb+x+ および
\verb+y+ 成分の値を持つオブジェクトとして初期化するコピーコンストラクタ 
\verb/ public: Vector2(const Vector2 & v)/ 
を宣言し，(2) と同様に呼び出されているかどうかの確認をできるようにして，プログラム中で
\verb+Vector2+ 型変数への代入を行い確かめよ．
\end{enumerate}

\end{exerc} %}

\begin{exerc} %\EXERCISE{
2次元ベクトル型を参考にして，2次正方行列型をクラスとして実現せよ．
また，簡単な主プログラムを作成し，意図したとおりに動作することを確認せよ．

2次正方行列型は，少なくとも，入力，出力，加算，減算，乗算の
各メンバ関数を持ち，それぞれの動作が確認されること．
なお，クラスの実現には，たとえば $2 \times 2$の2次元配列を用いればよい．

\end{exerc} %}


\subsection{C++では関数の引数の型や数が関数名の一部である}

コンストラクタは，すべてクラス名と同じである．
コンストラクタ以外にも，C++言語では，対象となるクラス（型）や引数，またその数が異なれば，異なる関数に同じ名前を付けることができる．
この機能を正しく使うと，例えば次元の異なるベクトルについてそれぞれ加算が定義されているように，扱うデータ型は異なるが人にとって同じ意味や機能を持つ関数を，同じ名前にすることができ便利である．
これはオブジェクト指向プログラミング言語に広く取り入れられている考え方の一つで，{\bf ポリモルフィズム} と呼ばれている．

この機能を使うと，まったく異なる意味や機能の関数を同じ名前にすることもできる．
つまり，混乱やミスを誘発するような使い方もできるので，注意が必要である．

\begin{exerc} %\EXERCISE{
先に作ったプログラムをあわせて，2次元ベクトル型と2次正方行列型の双方を使うプログラムを作れ．
このとき，加算や減算の関数が，同じ名前でもコンパイルでき，正しく動作することを確かめよ．
\end{exerc} %}

%C++io

\section{クラスでデータの集合を作る}

集合は数学の基本概念であると同時に，
その実現方法はプログラミングの重要な基礎である．
ここでは，トランプカードをつかったゲームの状況を表現するプログラムを例に，
クラスによる集合の実現を学ぶ．

\subsection{トランプの手札は，トランプカードの集合である}

一組のトランプカードを使うトランプゲームをプログラムするとしよう．
そのために，まずカード1枚を表すデータ型を考える．

トランプのカードには，スペード $\spadesuit$，
ダイヤモンド $\diamondsuit$，ハート $\heartsuit$，
クラブ $\clubsuit$ の 4 つの``スート (suit)''
\footnote{タロットではそれぞれ剣，コイン (またはペンタクル)，カップ，ワ
ンド (木杖) にあたり，アリストテレスの四元素説の 風，土，水，火 を表す．}があり，
それぞれのスートにエース (A)，2 から 10 までの字札，
そして Jack (J)，Queen (Q)，King (K) のコートカード (絵札) の
計 13 枚がある．
ここでは，さらに 1 枚ジョーカー (道化師) Joker を加え，
計53枚の一セット（デッキ）とする．

ここでは，カードのスートと番号を別々のメンバ変数として
持つトランプカード型 \verb+Card+ を考える．
\begin{quote}
\linesparpage{50}
\begin{verbatim}
class Card {
// メンバ変数
private: // カードのスートや番号を後で勝手に変えられても困る
        int suit;       // スート
        int number;     // 番号
// メンバ関数
public:
        ...
};
\end{verbatim}
\end{quote}
なお，\verb+suit+ の値とスペード，ダイアモンド等との具体的な対応は，
\verb+enum+ （列挙型）によって連番でつける．

次に，一人のプレーヤの「手」の表現方法を考える．
これは，トランプカードの集合であると考えられる．
手札の数は高々数十枚であるので，ここでは集合の実現に配列を用いることにする．
\begin{quote}
\linesparpage{50}
\begin{verbatim}
class CardSet {
// メンバ変数
// 定義・宣言
public:
        const int maxnumcard = 53;      // 全部持ったとしてもこの枚数
private:
        int numcard;            // 現在の集合内のカード数
        Card cdat[maxnumcard];  // カードの配列
// メンバ関数
	...
};
\end{verbatim}
\end{quote}
カードのデータは配列 \verb+cdat+ に入る．
また，実際にカードのデータが納められているのは配列 \verb+cdat+ の添字が  \verb+numcard+ 未満の要素であるとする．
ここでは，トランプを1デッキしか使わないことを仮定しているので，
配列は長さ53あれば十分である．
この 53 という決まった数をプログラムで参照するのに，C 言語では
\verb+#define+ コンパイラ指令による書き換えを利用して名前をつけていた．
C++ では，\verb+const+ 指定をして，初期化後に値の変更をしない変数，すなわち定数として宣言することができる．

\begin{exerc} %\EXERCISE{
トランプカード型およびトランプカードの集合型のソースファイルが
\verb+card.[h/cpp]+ および \verb+cardset.[h/cpp]+ として，
またそれを使った簡単な主プログラムが \verb+cardsetex1.cpp+ として，
それぞれ用意されている．
以下の演習を実施せよ．

\begin{enumerate}

\item[(1)] プログラムをコンパイルし，動作を確かめよ．

\item[(2)] クラス \verb+CardSet+ のメンバ関数 \verb+remove()+ 2種類を実装して \verb+cardset.cpp+ を完成させ，
また \verb+cardsetex1.cpp+の主プログラムでカード削除の動作テストが行えるようにし，確認せよ．
\end{enumerate}
挿入の手順と削除の手順の共通点に注意し，\verb+insert+ 関数を参考に実装せよ．
\end{exerc} %}

%C++ ではコンストラクタや \verb+CardSet+ クラスの \verb+remove( )+ 関数の
%ように，同じ名前で異なる引数の関数を定義できる．
%このように同じ名前で異なる関数を定義できる機構を {\bf ポリモルフィズム} という．

\section{クラスをもとにより大きなクラスを作る}

次に，具体的なトランプゲームをもとに，ゲームの状態を表すクラスを考える．
ここでは，最も簡単なカードゲームとして，いわゆる「ババ抜き」\footnote{もとは $\clubsuit$ の Queen
(Argine) を抜いて行う Old maid というゲームで，
Joker は日本でトランプに追加されたものだという．}
を取り上げる．
ババ抜きでは，参加プレーヤの持ち手 (持ち札) が
ゲームの状態を表すと考えることができる．
カードの集合型は既に実現しているので，
それを利用することを考えると，ババ抜きゲームの状態を表す型は以下のように
なる．
\begin{quote}
\linesparpage{50}
\begin{verbatim}
class BabaState {
// 定義・宣言
public:
        const int numplayer = 5;        // プレーヤ数
// メンバ変数
private:
        CardSet hand[numplayer];  // 各プレーヤの持ち手
// メンバ関数
        ...
};
\end{verbatim}
\end{quote}

ゲームの状態は，最初に全員にカードが配られた後は，あるプレーヤが別のプレー
ヤのカードを取り，
（プレーヤーが必要とするなら）番号が一致する2枚のカードを組で捨てることで進んでいく．
カードが配られるときの動作および配られた直後の動作はコンストラクタまたは関数 \verb+reset()+ で，
別のプレーヤーからカードを取り，一致する場合捨てる動作を関数 \verb+move()+ で実現しよう．

\begin{exerc} %\EXERCISE{
ババ抜きの状態を表現するための型がソースファイル
\verb+babastate.h+および\verb+babastate.cpp+に，
またそれを使った簡単なババ抜きプログラムが
\verb+babanuki.cpp+として，それぞれ用意されている．
以下の演習を実施せよ．

\begin{enumerate}

\item[(1)] \verb+BabaState::move()+は実現されていない．
これを実現し，またゲームを行って動作を確かめよ．

\end{enumerate}

\end{exerc} %}

\section{習うより慣れよ}

以下の課題から1つまたはそれ以上を選んで取り組め．
%\EXERCISE{
%\verb+babanuki1.cc+の主プログラムでは，
%カードは自動的に選ばれるため，現状では人間が関与する場面がない．
%自分が他のプレーヤのカードを取るさいは，
%例えば (列の中の) 順番を指定する等して，
%実際のゲームのように，人間が関与できるように変更し，実行せよ．
%}

\begin{exerc} %\EXERCISE{
ここまで，クラス \verb+Card+は \verb+suit+と\verb+number+という
二つの整数をメンバ変数に用いて実現してきが，
他の方法，例えば一つの char 型で表現する方法も考えることができる．

\verb+CardSet+クラスやメインプログラムに影響を与えることなく，
\verb+Card+クラスの実現方法を変更できることを，
実際に異なる方法で実現し，コンパイル，実行をして確認せよ．
\end{exerc} %}

\begin{exerc} %\EXERCISE{
ババ抜きの状態を表すクラス \verb+BabaState+ を別の実現方法で実現せよ．
例えば，長さ53の配列にそれぞれのカードの持ち主を記録しておく方法でも
状態を表すことはできる．

新たに実現した方法を比較し，長所と短所，そして結論としてどちらが選りすぐれているかを
根拠をしめしながら論ぜよ．
\end{exerc} %}

%\input{自由演習の部分とか．発展課題とか．}

\begin{appendices}

\section{レポートとその提出方法}

以下の標準的なレポートの形式に準じているか，よく確かめること．
いうまでもないが，ワープロソフトウェアを使う場合も，書式等に自分で責任を持つこと．
\begin{enumerate}
 \item A4, 縦置き，横書き，左上をステープラどめ．
余白は上下 25〜35mm，左右 22 〜 30mm
\item ワープロソフトなどを使う場合，文字スタイルは，本文文章は明朝体，タイトルや節見出しはゴシック．
英数文字は半角．
プログラムリストやコンソール出力は等幅（非プロポーショナル）体（Courier, Lucida, Consoals など）を使う．
ページ番号は，フッタ中央またはヘッダ右端に通しでつける．
 \item 文章の部分の行数，行字数，文字サイズは 30行/ページ 程度（行間1.25 〜 1.5 行），
40 〜 45文字/一行 程度（文字大きさ 11 〜 12pt）
\item 表題は 18pt 程度で，表紙または一ページ目に本演習のテーマ名，学生番号，氏名，実験日（３回分），提出日を記載する．
\end{enumerate}

内容は一般的なレポートの書き方にそって書くこと．
ただし以下が明確にわかるよう書くこと．
\begin{enumerate}
  \item 演習ごとに，行うこと，あるいは目的の説明．
  \item プログラムの自分で作成した部分のプログラムリスト．
プログラムのファイル全体は別に電子提出とするので，
ファイル名と行番号で参照したり，
最初に与えられたファイルそのままの部分，直前の演習と重複する部分などは省略するなど
簡潔になるよう工夫すること．
   \item 目的の関数などを実現するための考え方，特に自分で考えたこと．
   \item 動作の確認においては，確認する個々のことがらと，設計した確認方法，その結果から得られる結論．
   \item 考察，この演習で明らかになったこと，考えられる発展的な課題など，のまとめ．
\end{enumerate}
「むつかしかった」など，感想はいらないので，書かない\footnote{感想を書きたい場合は，別添やアンケート等でお願いします．}こと．

%\item 考察では可能であれば次のようなテーマについて考えてみよ．

\section{ソースファイルの構成法とコンパイル}

C や C++ では，原則として，以下のようにソースファイルを分割する．

\begin{enumerate}
 \item[(a)] {\bf ヘッダファイル}	\\
定数，型の定義(具体的には，構造体(や C++ のクラス)の定義になる)，
関数のプロトタイプ宣言を，名前が\verb+.h+で終るファイルにまとめる．
これを，ヘッダファイルという．
ヘッダファイルは，関連する型(1つの場合もある)ごとにまとめる．
 \item[(b)] {\bf プログラムファイル}	\\
C や C++ の関数の処理を記述するファイルをプログラムファイルという．
プログラムファイル名は，C 言語では \verb+.c+で，
C++ 言語は拡張子で区別し，\verb+.cc+，\verb|.c++|，\verb+.cpp+ などとする．
プログラムファイルの先頭では {\tt \#include}で必要なヘッダファイルを
インクルードする．

プログラムファイルは，例えば，それぞれの型毎に1つずつにわけ，
特定のアプリケーションの主プログラムなども，型とは別のファイルにする．
このようにすると，例えば上の例では，
2次元ベクトルを用いた主プログラムを変更しても，
2次元ベクトルの加算，減算などの関数のファイルには影響がないことになる．
\end{enumerate}

複数のソースファイルから成るプログラムをコンパイルするには，	\\
\hspace*{10mm}{\tt \% cc vector2c.c vec2ex1c.c}	\\
\hspace*{10mm}{\tt \% c++ vector2p.cpp vec2ex1p.cpp}	\\
のように，必要なソースファイル名を並べればよい．
また，\\
\hspace*{10mm}{\tt \% cc -c vector2c.c}	\\
\hspace*{10mm}{\tt \% cc -c vec2ex1c.c}	\\
のように，個々のファイル毎にコンパイルしておき，後で，	\\
\hspace*{10mm}{\tt \% cc vector2c.o vec2ex1c.o}	\\
のようにリンクだけ行なうこともできる．
これを{\bf 分割コンパイル}という．


\end{appendices}

\end{document}

\begin{quote}
\linesparpage{50}
\begin{verbatim}

\end{verbatim}
\end{quote}

\begin{quote}
\linesparpage{50}
\begin{verbatim}

\end{verbatim}
\end{quote}

\begin{quote}
\linesparpage{50}
\begin{verbatim}

\end{verbatim}
\end{quote}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%###########%%%


\EXERCISE{

1セットのトランプのカード(これをデッキという)でゲームすることを考える．
ここでは，1デッキには1枚のジョーカーを含む53枚のカードがあるとする．

1デッキ内のカードの部分集合を表す型
(これは1人のプレーヤーの手持ちのカードの集合や捨てカードの集合を表す)
を作れ．

}

\begin{enumerate}

 \item[(1)] カード1枚を表すデータ型を作る(作り方いろいろ)．

 \item[(2)] カードの集合(手持ちのカード)を表す型を作る．
(ただし，使用しているカードは1組とする．(同じカードは1枚しかない．)
(下薗先生案をちょっと変更．
実現方法いろいろ: 配列，線形リスト，ビット表現，木...
それぞれどんな長所短所があるかを考えさせる)

\end{enumerate}

\POINT{ポインタとポインタ引数の説明}{}

\POINT{ヒープとスタックの説明}{}

\section{C++言語で型を作る}

\subsection{C言語には抽象データ型を作りにくいところがある}

＃下薗先生の説明

\subsection{演習3}

\begin{enumerate}

 \item[(1)] 演習1の分数の型をクラスを使って書きかえよ．

\end{enumerate}

\subsection{演習4}

\begin{enumerate}

 \item[(1)] 演習2のカードの集合を表す型をクラスにせよ．
主プログラムを作り確認せよ．

 \item[(2)] 演習2のカードの集合を表すクラスの実現を変えよ．
同じ主プログラムで動くか．動かないとしたら何が原因か．

\end{enumerate}

\section{クラスをもとにより大きなクラスを作る}

\subsection{クラスのメンバ変数にクラスを含めればより大きいクラスが作れる}

分数の実数部，仮数部を持つ虚数クラスの実現

\subsection{演習5}

\begin{enumerate}

 \item[(1)] 虚数クラスを完成させなさい．

\end{enumerate}

\subsection{演習6}

\begin{enumerate}

 \item[(1)] 演習4のカードの集合クラスを用いて，
「ババ抜き」の全プレーヤの状態を表すクラスを作りなさい．
(どんな操作が必要か?)

\end{enumerate}

\section{習うより慣れろ}

\subsection{演習6}

\begin{enumerate}

 \item[(1)] 自分の好きな(カード?)ゲームの状態を表すクラスを作りなさい．
適当な主プログラムを作り，(少なくとも)電子ゲーム盤を作りなさい．
余力のある人は，簡単な思考ルーチンを作ってもよい．

\end{enumerate}

\section{ここで扱っていない大事なこと}

\begin{itemize}

 \item 型の間の関係の表し方(1対1，1対多，多対多)

 \item クラスの継承

 \item 演算子の再定義

 \item ...

\end{itemize}

\end{document}


・型とは何か

・抽象データ型

・データ構造は型の実現方法である

・問題に対していきなりベタで変数を書くのではない．
問題の規模に応じた(十分大きな，処理が書き易い)型を作るのが先決．

・型を実現するのに必要なことは，(1)一つのデータを一つにまとめる，(2)一つのデータをまとめて操作できること．

・一つのデータを一つにまとめるには，(Cでは)構造体を用いる．

・ヒープとスタック
・ポインタとポインタ引数

Cでの演習 (card)

・まとめて操作させる上で，Cの構造体は不便である

・情報隠蔽とポリモルフィズムの必要性

C++の説明と演習 (card)

・型を組み合わせてより大きな型を作る

・1対1

・1対多

・多対多

・冗長なデータはまとめてポインタで指す

\end{document}

「文書は人のためならず」という．

