%#!platex
%%#!jlatex209
%，
% 知能情報工学実験演習 I (2) C++演習 テキスト
% text02a.tex - 04/10/08 版 - 下薗＆乃万
%
%\documentstyle[11pt]{j-article}
\documentstyle[11pt,a4,epsf]{jarticle}
%\usepackage{amssymb}
%\input{a4}
%\setlength{\topmargin}{-1.5cm}
%\setlength{\oddsidemargin}{0cm}
%\setlength{\textwidth}{16cm}
%\setlength{\textheight}{25cm}
%\renewcommand{\@}[1]{{\bf #1}}
\title{{\normalsize 知能情報工学実験演習 II }\\
\bf C++演習 (Part 2)\footnote{2013年度版 下薗，嶋田 作} }
\author{担当: 中村貞吾，下薗真一\\
TA: 石田竹至，蓑代成功\\
\small
e-mail: 
{\sf \{teigo,  t\_ishida, minoshiro \} @dumbo.ai.kyutech.ac.jp},\\
\small
{\sf sin@ai.kyutech.ac.jp}
%\footnotesize
%{\sf t\_inoue@pluto.ai.kyutech.ac.jp}
}
%\date{第1.0.3版 \ 2004 年 10 月}
\date{May, 2015}
%
% 諸定義
%
\def\linesparpage#1{\baselineskip=\textheight\divide\baselineskip#1}
\newtheorem{exerc}{演習}
\newtheorem{adv}{発展課題}

\setlength{\textwidth}{165mm}       % テキストの幅
\setlength{\textheight}{255mm}      % テキストの高さ
\setlength{\oddsidemargin}{-2mm}     % 偶数ページの左マージン
\setlength{\evensidemargin}{0mm}    % 奇数ページの左マージン
\setlength{\topmargin}{-20mm}         % 上のマージン
%\setlength{\baselineskip}{10.0pt} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% 本文
%
\begin{document}
%\linesparpage{40}
\linesparpage{36}
\maketitle

\medskip

\begin{description}
%\item[期間:] 第 3 年次前期
%\item[機材:] 共通教育研究棟 3 階 S303 室 および S318 室の Linux PC 端末%\\
%	初回のみ 第 I 計算機室(研究棟 6 階)の Linux PC 端末
\item[注意:] \underline{Part 2 では，グループ単位でプログラムを作成し，レポートを作成，提出すること}．
\end{description}

\medskip

\section{グループ演習}
ババ抜きで利用したトランプカードを表す型 \verb+Card+ とカードの集合の実装である \verb+CardSet+ を用いて，トランプ・ゲームの「大富豪（大貧民）」をプレイする環境と思考ルーチンをそなえるプレーヤを作成し，オブジェクト指向言語によるモデル化にもとづくプログラミングとチームでのソフトウェア開発を実践する．

実現するシステム（体系）のよっている規則を完全に把握することが，
コンピュータによるシステム構築に不可欠である．
まず，実現するゲームのルールを確認しよう．

\section{大富豪/大貧民のルール}

大富豪は，ラミーや UNO と同様，場札の上に手札（の組）を捨てていき, 手札をなくしたプレーヤーが勝ちとなるタイプのゲームで, 52枚のカードとジョーカー1枚を使用する．
以下にルールを簡単に説明するが, 作成するプログラムのモデルを確認するために必要な程度にとどめる．  

まず親（ディーラー）は，カードをよくシャフルして，すべてのカードを大富豪から時計回りに一枚ずつ各プレーヤーに配る．
配り終えたら，ゲームを親のターンから開始する．
ターンが回ってきたプレーヤーは，手札から同じランクのカードを一枚以上，ジョーカーを含め四枚まで組として場に出せる．
このカードの組をリードという．
ただし，既に場に他人の出したリードがある場合は，同じ枚数のより強いランクの札の組でなければ出すことはできない．リードがペア, 3カード，あるいは 4 カードならば，次のプレイヤーは同じ枚数でより強いカードの組を出さねばならない．
出せない，出したくない場合は, 場に札を出さずにパスすることができる．
場にカードを出すか，パスすればそのプレーヤーのターンは終了である. 
ランクはジョーカーが最も強く, 続いて $2 > \mathrm{A} > \mathrm{K} > \mathrm{Q} > \mathrm{J} > 10 > \cdots > 3$ の順となる. 
全員がパスをつづけ，リードを出したプレーヤーにターンが回ってきた場合，リードは流れたとして，最後にカードを出した，つまりリードを出したプレイヤーがリーダーとなる．
リーダーは，自由にリードとなる札（の組）を選んで出すことができる．

最初に手札をなくしたプレーヤーが大富豪，つまり１位となる．
残るプレーヤーも勝ち抜けるまでゲームをつづけ，全員の順位を決める．
次のゲームは順位が低い方からターンがまわる．

その他，大富豪には多くのルールがあり，バリエーションやローカルルールとして
実際にプレイされなじんでいることも多いと思われる．
ただし，今回の演習では時間にも限りがあるため上記に述べた程度にとどめる．
次にあげるような点は，採用されないルールによる相違点の例となる．
\begin{enumerate}
\item[(1)] 最後に出す札には制限なし．
ジョーカーや 2 を最後の札としてあがってもよい．
\item[(2)] シークエンス (同じスートで複数の連続する数字のカードからなるもの）は，組としてみとめない．
\item[(3)] 革命 (4枚組，あるいは3の4枚組を出した場合，カードのランクの強さが逆転する．すなわち，強さが3＞4＞....の順となる) は起きない．
\item[(４)] 大富豪と大貧民の間のカードの交換（搾取），および都落ちは，ない．
\end{enumerate}

\section{プログラミングのためのモデル：大富豪プレーヤーの箱}
プログラミングを行う場合，特にオブジェクト指向言語では，プログラミングする対象を，担う機能や使用する資源にしたがって独立した部分や部品，単位にわけてデータ型（クラス）を設計する．
その場合，現実のものにあわせて，あるいは似せて作るのが最も効率的である．

今回，大富豪ゲームを複数プレーヤーが行う状況をプログラムにするにあたっては，
次のような考え方で作ることにする：

（１）ディーラーは，プレーヤーの一人（大貧民）が兼ねるのではなく，プレーヤーたちとは独立して中立に，ゲームをルールどおりに進行させる役割を担うものと考える\footnote{実際のカードゲームにおけるディーラーは，大貧民もしくはほかの誰かが行うが，このモデルではゲーム管理を行うクラスであり，実際にプレイするプレイヤーではないことに注意．}．

すなわち，札を配るだけでなく，ターンなどルールに従った行動をプレーヤーに対してうながす，またプレーヤーが出した札がリードとして通るかどうかを確認し，また他のプレーヤに確認させる，などコミュニケーションを司る役割を負う．
ゲームに参加するプレーヤーとその順位の管理も行う．
つまり，ディーラーは万能で完全に公平な立場をとるゲームの管理人である．

（２）プレイヤーは，プレイ中ターンの回ってくる参加者である．
プログラムにはカードやゲームについての前提知識はなく，大富豪をするためのテーブルもない．
そこで，カードのやりとり全てをディーラーに任せた系を考える．
プレーヤーは，「カードの出し入れだけができる引き出しがついた箱（に入っている人）」と考えればよいだろう．
プレーヤーのターンがまわってくる順番は，ディーラーがどの箱の引き出しをさわるかで決まる．
カードの配布は，ディーラーが引き出しにカードを入れることで行われる．
ディーラーはターンがきたプレーヤーの引き出しにリードを入れ，札を出すかパスするかを促す．
引き出しにリードとより強い組が入っていたら，新たなリードとして受け入れ，他のプレーヤーの引き出しに入れて見せる．
そうでなければ，リードを取り出し，その他のカードはそのままにして引き出しを押し返す．
そして，プレーヤーの手札がなくなったら，勝ち抜けを記録し，次のゲームでの順番とするのである．

人間同士でゲームをする場合，これらの「手順」にかわるものは，言葉や視覚によって暗黙のうちに完成している．
しかし，機械的なゲームの進行を実現するには，これらを限定的で明確なものにしなければならない．
たとえばネットワーク対戦を考えれば，プレーヤーが人であっても，機械であっても，
その必要があることを理解できるだろう．


\section{基本となるソースコードと拡張の方法}
ゲームを行う環境となる，\verb+Dealer.h/cpp+, \verb+Player.h/cpp+, \verb+GameState.h+ および \verb+main.cpp+ は, 変更を加えずにそのまま使用する．
クラス継承のしくみを使って，\verb+Player+ クラスを継承した別のプレーヤー用クラスを作り，ゲームの進行のために呼び出される関数を再定義する．
継承したクラスで新たに必要となる変数や関数も用意して，そのまま既存の \verb+Dealer+ クラス等とともにコンパイル，実行する．

グループでは，プレーヤーをシミュレートする \verb+Player+ の拡張クラスを作り，
カード配付後のゲーム開始直前に呼び出される \verb+ready()+, ターンがきた時に呼び出される \verb+follow( )+, および他のプレーヤーが捨てた札の確認を求められる \verb+approve+ の 3 つの関数（のうち必要なもの）を作成する．
継承による拡張のサンプルとして \verb+LittleThinkPlayer+ がある．
\verb+Player+ には手札をランダムに出す \verb+follow+ 関数が実装されており，動作の確認は可能である．
これを \verb+LittleThinkPlayer+ のように継承し，新たなプレーヤークラスで必要なデータ構造や手続きを作成，\verb+follow( )+ 関数などを書き換えるなどして，
グループ独自のより強いプレーヤーを作るのが目的となる．

\subsection{follow( ) 関数}
プレイヤーがまわってきたターンでカードを出すアクションは，\verb+Player::follow()+ のオーバーライド（定義の上書き）によって行う．
引数は，場札 (\verb+CardSet+) \verb+pile+ フィールドなどを持つゲーム状況をあらわす構造体 \verb+GameState+ 型データと，プレーヤーが出す札を入れるカードの集合で，
返値は常に \verb+true+ である．

基底クラスでありサンプルにもなっている \verb+Player+ クラスでは，
\begin{quote}
\linesparpage{50}
\begin{verbatim}
bool Player::follow(const GameState & gstat, CardSet & s) {
    CardSet pile(gstat.pile);   // 作業用に場札のカードセットをコピー
    Card tmp;
    s.makeempty();              // 念のためカラにする
    hand.pickup(&tmp, -1) );    // 手札からランダムに一枚選ぶ
    s.insert(tmp);              // 結局いいかげんに一枚出してみるだけ
    return true;                // 常に true を返す
}
\end{verbatim}
\end{quote}
となっている．
つまり場のカードについては考慮せず，自分の手持ちのカードセットからランダムに1枚出す，という動作を行っている．

\subsection{GameState 型}

場札をあらわす \verb+CardSet+ データのほか，プレーヤーの並び，各プレーヤーの手札の枚数など，プレーヤーがプレイ中に得られる情報をまとめた構造体である．
各フィールドの名称と意味は，以下のようになっている．
\begin{quote}
\linesparpage{50}
\begin{verbatim}
struct GameState {
    ...
	CardSet pile;        // 場札
	int nofPlayers;      // プレーヤー数
	int inTurn;          // ターンのまわってきたプレーヤー（プレー順での添字）
	int leader;          // 現在のリードを出したプレーヤー
	int nofCards[MAXIMUM_NUM_OF_PLAYERS];    // 各プレーヤーの手札の枚数
	int playerIDs[MAXIMUM_NUM_OF_PLAYERS];   // 各プレーヤーの ID 番号
    ...
};
\end{verbatim}
\end{quote}
場に札を出す上で最も重要なのは，\verb+pile+ フィールドであろう．
プレーヤーを表す整数は，プレー順でならんだプレーヤーの配列の添字である．
同じプレーヤーに対しても，ゲームが終了し順番がかわるとかわってしまう．
異なるゲームの間で同じプレーヤーを追跡したい場合は，
プレーヤーをあつめた時点でディーラーが割り振った ID を確認する．

\subsection{approve( ) 関数}
他人が場に捨てたカードセットなどの状況を確認する機会をプレーヤーにあたえるため，\verb+Player::approve()+ 関数が呼び出される．
\verb+Player+ クラスでは何も行っていない．
引数は，\verb+GameStatus+ 型データである．


\subsection{ready( ) 関数}
\verb+ready( )+ 関数は，はじめてのゲームで，あるいは1ゲームが終了し新しいゲームが始まる際に，一度だけ呼び出される．
場に出た強いカードを記憶している場合など，ゲームごとに変数の初期化が必要ならば，この関数の中で行う．

\subsection{注意点}
基本的に実装を考えるのは，\verb+ready()+, \verb+follow( )+, \verb+approve( )+ の 3関数のみである．
上記以外の \verb+Player+クラスで定義ずみの関数は，変更をしてはならない．
もちろん，必要な機能や操作を自分の拡張クラスに関数や変数として追加し，上記 3 関数で使用する，
といったことは自由に行ってよい．

プレイヤーが出したカードが現在の場に出ているカードと比較して受理できるかなどの判定は， \verb+Dealer+ が行うので考えなくて良い\footnote{ゲームとしての判定は \verb+Dealer+ が行うが，実際問題としては，場に出そうとしているカードが通るのかを \verb+Player+ も判定した方が良い．それを考慮せず，通らないカードを出してしまうと，パスしたという扱いになり，不利になる．}．
また，パスをしたい場合は，空のセットもしくは通らないカード(現在，場に出ているカードよりも弱いカード)を \verb+follow()+ に渡せばよい．
通らないカードセットは，\verb+Dealer+ によって手持ち札に戻される．
 
\begin{exerc}
拡張クラスでオーバーライドして，\verb+follow()+ ，また必要があれば \verb+approve( )+, \verb+ready( )+ を改良もしくは実装し，より知的な戦略に基づくプレーヤーを実現せよ．

ただし，提供される \verb+Card.h/cpp+, \verb+CardSet.h/cpp+, \verb+Dealer.h/cpp+, \verb+Player.h/cpp+, \verb+GameStatus.h+, および \verb+main.cpp+ のゲーム進行ルーチン部分は, 変更を加えずにそのまま使用できること．
\end{exerc}

\section{演習を進める上での注意}
リーダーを中心にグループ内で事前に役割分担を決め，プログラムを作成すること．
演習では，まず，何らかの戦略に基づくプレイヤーを複数実装する．
例えば，現在は1枚しか出せないが，複数のカード(ペアや3カードなど)を出せるようにしたり，選んだカードが場に通るかどうかを判定して出すなどが考えられる．
それぞれを対戦させたり，考察することで，より洗練されたプレイヤーに改良するプロセスを繰り返していく．

継承による拡張のサンプルとして，\verb+LittleThinkPlayer+を用意している．
最終的には，各班で \verb+Group+班番号 という名前の新たなサブクラス（例えば1班なら，\verb+Group1+）を作成し，大会に参加させる．
%本演習では，\verb+Player::follow()+ 内で，現在カードを出そうとしているプレイヤーの名前 \verb+name+ で判別するのが最も簡単である．
\begin{quote}
\linesparpage{50}
\begin{verbatim}
class LittleThinkPlayer : public Player {
// LittleThinkPlayer は Player のサブクラス(派生クラス)
　　CardSet memory;
public:
　　LittleThinkPlayer(const char *);
　　bool follow(CardSet &, CardSet &);
　　bool approve(CardSet &, int[]);
};
\end{verbatim}
\end{quote}
班内でさまざまなアイディアを試すには，戦略ごとにサブクラスを定義して対戦させればよい．
\verb+main.cpp+関数で，以下のように参加させることができる．
\begin{quote}
\linesparpage{50}
\begin{verbatim}
d.regist(new Player(“Erika”)); 　
　// Player.cpp の follow() や approve() 
d.regist(new LittleThinkPlayer("Warabi")); 
　// LittleThinkPlayer.cpp の follow() や approve() 
\end{verbatim}
\end{quote}
%void Player::follow(const CardSet & tbl, CardSet & s) {
%    ....
%    if (name == "Konomi") { /* プレイヤー名 Konomi の戦略 */}
%    if (name == "Takenoko") { /* プレイヤー名 Takenoko の戦略 */}
%    ....
%}

実験の最後の時間に各班で作成した思考ルーチンを対戦させる．
具体的には，ランダムに割り振られた予選リーグを行い，各予選リーグで1位の班で決勝リーグを構成する．
この順位は最終的な成績に加味する．

\section{レポートについて}
レポートの作成には，全員が参加すること．
以下の書式・期日で各班ごとに1つ提出すること．
\begin{enumerate}
 \item A4 のレポート用紙を用い，左上部をステープラでとめる．
その他，Part 1 でのレポートに準ずる．
 \item 表紙には，演習名 (知能情報工学実験演習 II\ C++演習：グループ演習)，全班員の学生番号と名前，提出日を記載すること．
 \item 各班員の役割分担や貢献内容，レポートの分担を具体的に書くこと．
最終的に採用されなかった戦略なども含めて書いてよい．
 \item 班で作成したプログラムのリスト (ただし，最終的に実装したもののみでよい)．
 \item 実装した思考ルーチンの説明 (工夫した点および不完全な点を含む)
 \item 実行結果 (主要な部分・レポートでの説明に必要な部分のみでよい)
 \item 全体の考察\footnote{感想ではなく考察をすること．「面白かった．」や「難しかった．」だけではダメ．}とまとめ
 \end{enumerate}
レポートは，このテーマの実験最終授業日の翌週の同一曜日までに，研究棟 6 階のレポートボックスに提出すること．
レポートは評価され，不備のあるものは〆切から1週間以内に知能の掲示板に再レポートの掲示をするので，注意しておくこと．

%班ごとのレポートとは別に，個人単位でA4サイズ1枚の個人評価票(書式指定)も提出すること．
\end{document}

\begin{quote}
\linesparpage{50}
\begin{verbatim}

\end{verbatim}
\end{quote}

\begin{quote}
\linesparpage{50}
\begin{verbatim}

\end{verbatim}
\end{quote}

\begin{quote}
\linesparpage{50}
\begin{verbatim}

\end{verbatim}
\end{quote}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%###########%%%


\EXERCISE{

1セットのトランプのカード(これをデッキという)でゲームすることを考える．
ここでは，1デッキには1枚のジョーカーを含む53枚のカードがあるとする．

1デッキ内のカードの部分集合を表す型
(これは1人のプレーヤーの手持ちのカードの集合や捨てカードの集合を表す)
を作れ．

}

\begin{enumerate}

 \item[(1)] カード1枚を表すデータ型を作る(作り方いろいろ)．

 \item[(2)] カードの集合(手持ちのカード)を表す型を作る．
(ただし，使用しているカードは1組とする．(同じカードは1枚しかない．)
(下薗先生案をちょっと変更．
実現方法いろいろ: 配列，線形リスト，ビット表現，木...
それぞれどんな長所短所があるかを考えさせる)

\end{enumerate}

\POINT{ポインタとポインタ引数の説明}{}

\POINT{ヒープとスタックの説明}{}

\section{C++言語で型を作る}

\subsection{C言語には抽象データ型を作りにくいところがある}

＃下薗先生の説明

\subsection{演習3}

\begin{enumerate}

 \item[(1)] 演習1の分数の型をクラスを使って書きかえよ．

\end{enumerate}

\subsection{演習4}

\begin{enumerate}

 \item[(1)] 演習2のカードの集合を表す型をクラスにせよ．
主プログラムを作り確認せよ．

 \item[(2)] 演習2のカードの集合を表すクラスの実現を変えよ．
同じ主プログラムで動くか．動かないとしたら何が原因か．

\end{enumerate}

\section{クラスをもとにより大きなクラスを作る}

\subsection{クラスのメンバ変数にクラスを含めればより大きいクラスが作れる}

分数の実数部，仮数部を持つ虚数クラスの実現

\subsection{演習5}

\begin{enumerate}

 \item[(1)] 虚数クラスを完成させなさい．

\end{enumerate}

\subsection{演習6}

\begin{enumerate}

 \item[(1)] 演習4のカードの集合クラスを用いて，
「ババ抜き」の全プレーヤの状態を表すクラスを作りなさい．
(どんな操作が必要か?)

\end{enumerate}

\section{習うより慣れろ}

\subsection{演習6}

\begin{enumerate}

 \item[(1)] 自分の好きな(カード?)ゲームの状態を表すクラスを作りなさい．
適当な主プログラムを作り，(少なくとも)電子ゲーム盤を作りなさい．
余力のある人は，簡単な思考ルーチンを作ってもよい．

\end{enumerate}

\section{ここで扱っていない大事なこと}

\begin{itemize}

 \item 型の間の関係の表し方(1対1，1対多，多対多)

 \item クラスの継承

 \item 演算子の再定義

 \item ...

\end{itemize}

\end{document}


・型とは何か

・抽象データ型

・データ構造は型の実現方法である

・問題に対していきなりベタで変数を書くのではない．
問題の規模に応じた(十分大きな，処理が書き易い)型を作るのが先決．

・型を実現するのに必要なことは，(1)一つのデータを一つにまとめる，(2)一つのデータをまとめて操作できること．

・一つのデータを一つにまとめるには，(Cでは)構造体を用いる．

・ヒープとスタック
・ポインタとポインタ引数

Cでの演習 (card)

・まとめて操作させる上で，Cの構造体は不便である

・情報隠蔽とポリモルフィズムの必要性

C++の説明と演習 (card)

・型を組み合わせてより大きな型を作る

・1対1

・1対多

・多対多

・冗長なデータはまとめてポインタで指す

\end{document}

「文書は人のためならず」という．

