%#!platex
%%#!jlatex209
%
% 知能情報工学実験演習 I (2) C++演習 テキスト
% text02a.tex - 04/10/08 版 - 下薗＆乃万
%
%\documentstyle[11pt]{j-article}
\documentstyle[11pt]{jarticle}
\input{A4}
\renewcommand{\@}[1]{{\bf #1}}
\title{{\normalsize 知能情報工学実験演習 I -- 2} \\
\bf C++演習}
\author{担当: 下薗真一・乃万　司・山本邦雄・松元隆二
(TA: 樽本瑶子)	\\
E-mail: \footnotesize
{\sf \{sin,noma,kunio,matumoto\}@ai.kyutech.ac.jp},
{\sf y\_taru@pluto.ai.kyutech.ac.jp}}
\date{第1.0.3版 \ 2004 年 10 月}
%
% 諸定義
%
\def\linesparpage#1{\baselineskip=\textheight\divide\baselineskip#1}
%%%%% 演習問題の表示 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcounter{execnumber}
\setcounter{execnumber}{0}
\newcommand{\EXERCISE}[1]{
 \medskip
 \refstepcounter{execnumber}
 \begin{center}
  \fbox{
   \begin{minipage}{\textwidth}
    \noindent
    {\bf 演習 \arabic{execnumber}}
    #1
   \end{minipage}
  }
 \end{center}
 \medskip
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% ワンポイントの表示 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcounter{pntnumber}
\setcounter{pntnumber}{0}
\newcommand{\POINT}[2]{
 \medskip
 \refstepcounter{pntnumber}
\noindent
■■■■■ {\sf Point \arabic{pntnumber}:} {\bf #1} \hrulefill ■ \\
{\small #2}

\noindent
■ \hrulefill ■■■■■ \\
% \begin{center}
%  \fbox{
%   \begin{minipage}{\textwidth}
%    \noindent
%    {\bf ポイント \arabic{pntnumber} (#1)}
%    #2
%   \end{minipage}
%  }
% \end{center}
 \medskip
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% 本文
%
\begin{document}
\linesparpage{40}
\maketitle

\medskip

\begin{quote}
\begin{description}
\item[期間:] 第 2 年次後期，毎週金曜日午後
\item[機材:] CAD実験室(共通教育研究棟 3 階 S303 室)の Linux PC 端末%\\
%	初回のみ 第 I 計算機室(研究棟 6 階)の Linux PC 端末
\item[注意:] 実験は 3 回に分けて行うが，
実験・演習に割り当てられている時間以外でも，
自由に計算機を使用してかまわない．
研究棟側の端末でも実験は可能である．	\\
\underline{実験は個人単位で行ない，各人別々にプログラムを作成すること}．

\end{description}
\end{quote}

\medskip

この演習では，C 言語および C++ 言語を使うプログラミングをしながら，役に
立つ実用的なプログラムを作るときに必要なプログラミングスタイル，つまり読
みやすくミスの生じにくいプログラムの書き方を身につける．
その中で，構造化プログラミングと，その発展形であるオブジェクト指向プログ
ラミングの基礎を理解し使いこなせるようになってもらう．

\section{はじめに：初心者プログラムを書くのはやめなさい}

\subsection{プログラムを作る時にずらずらと変数宣言をするのはやめなさい}

プログラムを書くとき，あまり深く考えずに，とりあえず必要そうな変数を
%\verb+int+とか\verb+double+など単純な既存の型で
山のように宣言する人を見かける．
使われていない変数や関数の引数があっても気にしないのである．
もし自分がそうだと思うなら，{\bf 今日からやめること}．

プログラムが自分で一度か二度使う程度の簡単なおもちゃプログラムならそれで
もよいだろう．
演習の課題で，先生が○をつけてくれればいいのなら，それでもよいだろう．
しかし，将来仕事や研究で作る「世の中の多くの人の役に立つプログラム」は，ほとんどの場合構造を持
つデータを対象に複雑な計算を行う．
プログラムは大勢で共同で作ることも珍しくない．
とりあえずで書きはじめると，わかりにくくミスの生じやすいプログラムになり，結局後で大幅な書き直しが必要になる．
そのような習慣は早いうちに捨てなければならない．



\subsection{プログラムはまずデータ型から作りなさい}

Niklaus Wirth\footnote{著名な計算機科学者．チューリング賞受賞者．}
の名著(の一つ)に「アルゴリズム+データ構造=プログラム」という本がある．
操作とその対象は，常に対応させて考えなければならない．
この実験演習では，「アルゴリズム+データ型=プログラム」という立場\footnote{
データ型をうまく実現する際にデータ構造を考える必要がある．
Wirth の書名は今でも意味がある．}
から，プログラムを作る際に{\bf まず「適切なデータ型」を作る}のを習慣づけ
ることを目的としている．

C++はクラスというメカニズムでデータ構造とその操作をはっきり対応させたプ
ログラムを書くことができる言語である．


\subsection{大域変数はやめなさい}

大域変数は，プログラムのどこででも使える，関数と関数の間でのデータ受け渡しに
使える大変便利な変数である．
しかし，プログラムが全体を見渡すことができないほど大きくなり，関数の動作
が複雑になると，どこでどの変数を変更したか，なんのための変数だったかがわ
からなくなり，失敗やムダの原因になる．
とりわけ，プログラミングをオブジェクト指向スタイルに変えようとするとき，
大域変数をつかうくせは，大きな障害になる．

データを型として組み合わせひとまとめにすると同時に，プログラムの部分部分
で「使う変数を最少限にひとまとまりにしておく」のが，プログラムをうまく作る
コツの一つである．
関数のデータのやり取りも，関数の動作や操作対象をコンパクトかつ明確にする
ために，引数と返り値のみで行なうべきである．


\section{C言語で型を作る}

\subsection{データ型とは一定の意味を持たせたモデルと操作の組合せである}

例えば，実験演習に使用中の Linux PC 端末では，
\verb+int+型も\verb+float+型も同じビット列を取ることがある\footnote{
同じ浮動小数点数でも，\verb+double+型は8バイトであるが，
\verb+float+型は\verb+int+型と同じ4バイトなので，
ここでは\verb+float+型を例にしている．}．
例えば，整数\verb+1040187392+と実数\verb+0.125F+はどちらもビット列 
\[
\verb+0011 1110 0000 0000 0000 0000 0000 0000+
\]
(\verb+3E 00 00 00+) になる．
また，計算機のハードウェア側には，どのアドレスのデータが
\verb+int+型で，どのアドレスのデータが\verb+float+型かといった情報は存在
しない．

我々が，適切に\verb+int+型の計算と\verb+float+型の計算を
使い分けられるのは，
プログラムの中で \verb+int+型のデータには\verb+int+型の操作 (命令) が，
\verb+float+型のデータには\verb+float+型の操作が選ばれることによって，
適切に計算が行なわれるからである\footnote{
実際には\verb+float+型は\verb+double+型に変換されて計算される．}．
例えば，\verb+int+型の計算では，ビット列を\verb+int+型として
解釈して計算し，計算結果も\verb+int+型として解釈できるビット列に
直してレジスタやメモリに格納する．
つまり，{\bf データの意味は操作で決まる}．

データ型の本質は，内部表現の方法ではなく，
{\bf モデル}(例えば数学でいうところの「整数」)と
{\bf 操作}(例えば\verb+int+型の演算)にある．
これは，\verb+int+型や\verb+float+型がメモリの中でどのように表されるかを知らなくても，プログラムを書いたりできることからも明らかである．
%\footnote{ふつうは
%自分が使っている計算機がbig-endianかlittle-endianかすら気にしない．}．
実際，データ型がどんな内部表現だろうと，操作がその内部表現に適応していれ
ば，外部からは内部表現の違いを気にすることなく使える．



\EXERCISE{
C言語で，以下の指示に従ってプログラムを作り動作させて結果を調べよ．
また，なぜそのような結果になるのかを説明せよ．
\begin{enumerate}
\item[(1)] まず，長さ 4 の文字列によって初期化された文字配列 \verb!s! と，\verb!s! とおなじアドレスを指す整数型へのポインタ \verb!p! を宣言せよ．\\
例）\verb!  char s[] = "abcd"; !\\
　　\verb!  int * p = (int *) s;!\\
ただし，\verb!abcd! の部分は他の人と同じにならないよう変更すること．
\item[(2)] その 4 文字を文字列として，またポインタ \verb!p! により \verb!int!型とみなしてそれぞれ印字し，どのような値を表すか確認せよ. \\
例）\verb!  printf("As a string: \%s, as an integer: \%d$\backslash$n", s, *p;!
\item[(3)] 文字列を \verb!p! により整数と見なして，加算等により値を変更せよ．\\
例） \verb!  *p += 3; ! \\
そして上と同様に印字して，どのような変化があるかを確かめよ．

\end{enumerate}

}



\subsection{計算機中に存在しないものを表すのが抽象データ型である}

プログラムで必要となるデータ型には様々なものが考えられるが，
プログラミング言語があらかじめそのすべてを用意することはできない．
極端な話，整数や浮動小数点数ですら，桁の制限や精度の制限があり，数学的な整数や実数を表しているわけではない．
そこで必要なデータ型は，使える型を組み合わせて{\bf 自分で作る}のである．
これが{\bf 抽象データ型}である．

自分で型を作るとき，以下の二つのことが必須となる．
\begin{enumerate}

 \item[(1)] データ一個を表すのに必要なデータ（値）は，すべて一つにまとめる．	\\
既存の型でも，例えば，
浮動小数点数の符号部と指数部と仮数部は必ず一まとまりにして扱っている．
分けて見たり操作する必要はない．

 \item[(2)] 一個のデータは，いつもまとめて操作する．	\\
既存の型でも，例えば，浮動小数点数の演算をすると，
符号部も指数部も仮数部も一緒に計算される．

\end{enumerate}
なぜなら，人間にとって，一つと考えられるものは「一つ」として扱えるほうがわかりやすく，楽で間違いがないからである．

\subsection{データを一まとめにするには構造体を使う}

データを一まとめにするには，必要なデータを組み合わせる．
C言語では，構造体 (struct) を宣言することによって行う．
(C++言語では，構造体をクラスともよぶ．)
組み合わせに使うデータの型が，言語で用意されたものか，別の抽象データ型かは問われない．

例えば，2次元ベクトルを表すには，
それぞれの成分を例えば \verb+double+ 型で表す必要があるから，
次のような構造体 \verb+vector2+ を作ればよい．
\begin{quote}
\linesparpage{50}
\begin{verbatim}
struct vector2 {
        double x;       /* x値 */
        double y;       /* y値 */
};
\end{verbatim}
\end{quote}
もちろん，\verb!double val[2];! のようにして，x, y の各値を配列の要素で表すこともできる．


\subsection{データの操作は一まとめになっている単位で行なう}

データには，内部表現を気にすることなく一まとまりとして扱えるよう操作を準備する．
例えば浮動小数点数の加算では，指数部や仮数部の計算は表には見えない．
同じように，抽象データ型の操作も，その型のデータそのものを扱うような関数
を準備して使う．
こうすることによって，\underline{内部表現を変更しても操作関数を変更する
だけで済む}．

例えば，2次元ベクトルの加法演算は，
\begin{quote}
\linesparpage{50}
\begin{verbatim}
struct vector2 addv2(struct vector2 u, struct vector2 v)
{
        struct vector2 ret;

        ret.x = u.x + v.x;
        ret.y = u.y + v.y;

        return ret;
}
\end{verbatim}
\end{quote}
と用意し，プログラムで 2次元ベクトル同士の加算が必要なら，
\begin{quote}
\linesparpage{50}
\begin{verbatim}
vec0 = addv2(vec1, vec2);
\end{verbatim}
\end{quote}
などと書く．
操作関数を作る手間を惜しんで，いちいち
\begin{quote}
\linesparpage{50}
\begin{verbatim}
vec0.x = vec1.x + vec2.x;
vec0.y = vec1.y + vec2.y;
\end{verbatim}
\end{quote}
などと書いていれば，かえって手間がかかるばかりでなく，後で何をしたかった
のかがわかりにくいコードになり，プログラミングを破綻させる原因になる．

\subsection{抽象データ型は関数の作り方の指針でもある}

今までは，関数の宣言のしかたはわかっていても，
なにを一つの関数にすればよいのか，わからなかったかもしれない．
抽象データ型の考えを使えば，{\bf あるデータ型をあつかう関数は，その型のデー
タの操作として意味のある関数にする}
という，関数の作り方の指針が明確になる．

プログラムを作る際は，組み込みの型から小さな型を，
小さな型から大きな型を作っていく．
同様に，関数もデータに必要な操作ごとに，小さな型のための関数を組み合わせ
大きな型のための関数を作ってゆく．
こうすることで抽象度の高いレベルで処理を簡潔に記述でき，
自然ときれいな ------ つまり読みやすくミスの起きにくい ------
プログラムが書けるのである．

\EXERCISE{
(C言語による) 2次元ベクトル型のソースファイルが，
\verb+vector2c.h+ および \verb+vector2c.c+ として，
またそれを使った簡単な主プログラムが \verb+vec2ex1c.c+ として，
それぞれ用意されている．以下の演習を実施せよ．

\begin{enumerate}

\item[(1)] プログラムをコンパイルし，実際に動くことを確かめよ．

\item[(2)] 減算の関数を \verb+vector2c.h+ および \verb+vector2c.c+ に
追加し，また，\verb+vec2ex1c.c+ の主プログラムに減算のテストを追加し，
実際に動くことを確かめよ．

%%% 検討: 内積の関数
%%% 検討: 引数をポインタ型に変える演習

\end{enumerate}

}

\POINT{ソースファイルの構成法とコンパイル}{
C や C++ では，原則として，以下のようにソースファイルを分割する．

\begin{enumerate}

 \item[(a)] {\bf ヘッダファイル}	\\
定数，型の定義(具体的には，構造体(や C++ のクラス)の定義になる)，
関数のプロトタイプ宣言を，名前が\verb+.h+で終るファイルにまとめる．
これを，ヘッダファイルという．
ヘッダファイルは，関連する型(1つの場合もある)ごとにまとめる．

 \item[(b)] {\bf プログラムファイル}	\\
C や C++ の関数の処理を記述するファイルをプログラムファイルという．
プログラムファイル名は，C 言語では \verb+.c+で，
C++ 言語では \verb+.cc+，\verb|.c++|，\verb+.cpp+ などで終るようにする．
プログラムファイルの先頭では {\tt \#include}で必要なヘッダファイルを
インクルードする．

プログラムファイルは，例えば，それぞれの型毎に1つずつにわけ，
特定のアプリケーションの主プログラムなども，型とは別のファイルにする．
このようにすると，例えば上の例では，
2次元ベクトルを用いた主プログラムを変更しても，
2次元ベクトルの加算，減算などの関数のファイルには影響がないことになる．

\end{enumerate}

複数のソースファイルから成るプログラムをコンパイルするには，	\\
\hspace*{10mm}{\tt \% cc vector2c.c vec2ex1c.c}	\\
\hspace*{10mm}{\tt \% c++ vector2p.cc vec2ex1p.cc}	\\
のように，必要なソースファイル名を並べればよい．
また，\\
\hspace*{10mm}{\tt \% cc -c vector2c.c}	\\
\hspace*{10mm}{\tt \% cc -c vec2ex1c.c}	\\
のように，個々のファイル毎にコンパイルしておき，後で，	\\
\hspace*{10mm}{\tt \% cc vector2c.o vec2ex1c.o}	\\
のようにリンクだけ行なうこともできる．
これを{\bf 分割コンパイル}という．
}

\section{C++言語で型を作る}

\subsection{C言語での型作りの弱点}

前節のように，C言語でも抽象データ型を作ることはできるが，
ソースコードがもっと複雑で大規模になった場合,
あるいは複数のプログラマで分担して作業するような場合に，
次のような問題や不都合が生じる．

\begin{enumerate}
 \item[(1)] 
構造体 \verb+vector2+ のメンバ変数に，どのような状況でも直接アクセスができる．
メンバ変数の値が直接変更されると，どのような影響があるかがわかりにくい．
プログラマの心がけに任せるばかりでなく，
むしろ積極的に，\verb+vector2+ をベクトルとして利用する部分では
\begin{quote}
\linesparpage{50}
\begin{verbatim}
vec0.x = vec1.x + vec2.x;
vec0.y = vec1.y + vec2.y;
\end{verbatim}
\end{quote}
のようなプログラムは書けないように制限したい．
 \item[(2)] 
加算には，2次元ベクトルの加算だけでなく，3次元ベクトルや行列の加算もある．
それらは「加算」という意味では同じであるが，引数の型が異なるため\verb+addv2+，\verb+addv3+，
\verb+addmatrix+ など，それぞれ別の関数名を付ける必要があり，命名と利用の両面で煩わしい．
\item[(3)] 
変数の宣言や動的割り付けを行った直後に，その変数の各メンバ変数の値がどうなっている
のか，あるいはどうする必要があるのかがプログラムからはっきりしない．
初期値が 0 や \verb+NULL+ なのか，あるいは不定なのかはコンパイラや環
境にも依存する．
メンバ変数に抽象データ型が使用され入れ子になっている場合，どこまで初期値の面倒をみれば
いいのかも不明であり，めんどうである．
\end{enumerate}


\subsection{C++言語ではクラスによって型作りが楽になる}

C++ では，こののような問題を解決するために{\bf クラス}というデータ型定義
の機構が提供されている．
クラス \verb+class+ は，C言語の構造体 \verb+struct+ を拡張したもので，「データを一まとめにする」機能に加え，
初期化や操作，アクセスなどそのデータに必要な関数も一まとめにすることができ，またそのデータの内部，つまりメンバ変数や関数へ外からアクセスできるかどうかの制御もできる
\footnote{実は C++ では構造体 {\tt struct} も関数を持てるよう拡張されていて，その違い
は情報隠蔽を明示的に行うか否かの違いだけである．}．
これは{\bf データと手続きのカプセル化 encapsulation}と呼ばれ，
オブジェクト指向プログラミングでの考え方の一つである．

2次元ベクトル型をクラスで表現すると以下のようになる．
(なお C++ では，\verb+//+から行末まではコメントになる．)
\begin{quote}
\linesparpage{50}
\begin{verbatim}
class Vector2 {
// メンバ変数
private:
        double x;       // x値
        double y;       // y値
// メンバ関数
public:
        Vector2(void)   { }
                // デフォルトコンストラクタ(初期値不定)
        Vector2(double x0, double y0);
                // x0, y0 を与えて定数 (x0, y0) を得るコンストラクタ
        Vector2 add(Vector2 u);
                // 自身のベクトルとベクトル u との和を求める
        ....
};
\end{verbatim}
\end{quote}
このように，メンバ変数と同様に，その型専用の関数も記述できるのである．

クラスでのメンバ変数の宣言は，構造体での宣言と同じである．
ただし，アクセス指定子 \verb+private:+ によって，メンバ変数 \verb+x+と
\verb+y+ をこのクラスのメンバ関数 (後述) だけがアクセスできる
「プライベート (私的) な」変数とすることができる．
これにより，メンバ変数が知らないうちに --- 
つまりクラスの定義以外の場所で --- 変更されるプログラムが書かれてしまう心配がなくなる．

データのクラスにそなわるメンバ関数を呼び出すときは，構造体のメンバ変数と同様に，変数に \verb+.+ で結び付けた形で記述する．
例えば，
\begin{quote}
\linesparpage{50}
\begin{verbatim}
Vector2 v1, v2, v3;
...
v3 = v1.add(v2);
\end{verbatim}
\end{quote}
という形で呼び出す．
これは，C言語の場合には，
\begin{quote}
\linesparpage{50}
\begin{verbatim}
v3 = addv2(v1, v2);
\end{verbatim}
\end{quote}
のように書いていたプログラムに相当する．

クラス内で宣言したメンバ関数の実体は，例えば次のようにプログラムする．
\begin{quote}
\linesparpage{50}
\begin{verbatim}
Vector2 Vector2::add(Vector2 u)
{
        Vector2 ret;

        ret.x = x + u.x;
        ret.y = y + u.y;

        return ret;
}
\end{verbatim}
\end{quote}
ここで，ただの \verb+x+ と \verb+y+ は\footnote{実際には「このデータ (オ
 ブジェクト)」のポインタを表す \verb+this+ を使って \verb+this->x+ と \verb+this->y+
 と書くところで，\verb+this+ が省略されている．}
 \verb+add+ 関数を呼び出した（作用する）変数のメンバ変数，つ
まり \verb+v1.add(v2)+ では \verb+v1+ のメンバ変数 \verb+v1.x+,
\verb+v1.y+ を指す．

上の例では，メンバ関数はアクセス指定子 \verb+public:+ によって外部から使
うことができる「公開された」関数になっている．
メンバ変数，メンバ関数は，
それぞれ \verb+private:+ (そのクラス以外からはアクセス不可能)，
あるいは \verb+public:+ (そのクラス以外からもアクセス可能) にできる．
メンバ変数を \verb+private:+ に，
メンバ関数を \verb+public:+ にするのが典型的である．


\subsection{C++言語では変数の初期化をはっきり型に書く}

クラス名と同じ関数名のメンバ関数は，{\bf コンストラクタ}と呼ぶ．
コンストラクタはそのクラス（型）の変数の場所をメモリ上に確保するときに呼び出され，その変数が持つメンバ変数の値を設定する．
その返り値は，そのクラス型のデータ (オブジェクト) と決まっているので，返値は記述しない．
変数の初期化し忘れを防ぐために，コンストラクタは必ず呼び出されることになっ
ている．
コンストラクタは引数を持つこともでき，初期化に使う値を引数で指定したり，他の型のデータを初期化に使うものも作成できる．
引数の無いコンストラクタは変数宣言などの際に暗黙のうちに呼び出され
るので，特に {\bf デフォルトコンストラクタ} と呼ばれる．

コンストラクタは，変数宣言などプログラマが意識して行う場合のほかにも，
代入 \verb+=+ や型変換 (タイプ・キャスト) で気づかないうちに呼び出されることもあるため，プログラムのミスの原因になることがある\footnote{Java や Smalltalk (Squeak) などの言語では，クラス型データはポインタなど
間接参照が基本なので目立たないが，C/C++ では構造体の代入や引数での値参照
が可能なので，注意が必要である．}．
代入やコピーで呼び出されるコンストラクタは{\bf コピーコンストラクタ}とよ
ばれ，引数は同じクラスのデータへの参照 \verb+&+ 一つのみである．
C++ プログラミングでのミスを減らすには，自分で作るクラスにはデフォルトコ
ンストラクタ，コピーコンストラクタはとりあえず作っておく習慣をつけるとよい．

\EXERCISE{
(C++言語による) 2次元ベクトル型のソースファイルが，
\verb+vector2p.h+および\verb+vector2p.cc+として，
またそれを使った簡単な主プログラムが\verb+vec2ex1p.cc+として，
それぞれ用意されている．以下の演習を実施せよ．

\begin{enumerate}

\item[(1)] プログラムをコンパイルし，実際に動くことを確かめよ．

\item[(2)] クラス \verb+Vector2+ の減算のメンバ関数を
\verb+vector2p.h+ および \verb+vector2p.cc+ に追加し，
また，\verb+vec2ex1p.c+ の主プログラムに減算のテストを追加し，
減算が行われることを確かめよ．

%%% 検討: 内積の関数
%%% 検討: 引数をポインタ型に変える演習

\end{enumerate}

}

\EXERCISE{
コンストラクタが明示的に，また暗黙の内に選択的に呼び出されることを以下の
方法で確かめよ．
\begin{enumerate}
\item[(1)] 
デフォルトコンストラクタ \verb+Vector2(void)+ で，\verb+x+ と \verb+y+
に初期値 \verb+0+ がセットされるよう変更し，\verb+printf+ 等で変数宣言な
	   どの直後に初期化されているかどうかを確かめよ．
\item[(2)] 
デフォルトコンストラクタと，コンストラクタ
\verb+Vector2(double, double)+ の中で \verb+printf+ 等でメッセージの印字
を行うようにして，適切なコンストラクタが呼び出されているかどうかの確認をせ
よ．
\item[(3)]
値のセットされた \verb+Vector2+ 型オブジェクトと全く同じ \verb+x+ および
\verb+y+ 成分の値を持つオブジェクトとして初期化するコピーコンストラクタ 
\verb/ public: Vector2(Vector2 \& v)/ 
を宣言し，(2) と同様に呼び出されているかどうかの確認をできるようにして，プログラム中で
\verb+Vector2+ 型変数への代入を行い確かめよ．
\end{enumerate}

}

\EXERCISE{
2次元ベクトル型を参考にして，2次正方行列型をクラスとして実現せよ．
また，簡単な主プログラムを作成し，実際に動くことを確認せよ．

2次正方行列型は，少なくとも，入力，出力，加算，減算，乗算の
各メンバ関数を持つようにせよ．
なお，クラスの実現には，$2 \times 2$の2次元配列を用いればよい．

}


\subsection{C++言語では同じ名前の関数が引数と返値の型で変わる}

コンストラクタは，すべてクラス名と同じである．
コンストラクタ以外にも，C++言語では，対象となるクラス（型）や引数，またその数が異なれば，異なる関数に同じ名前を付けることができる．
この機能を正しく使うと，例えば次元の異なるベクトルの加算のように，扱うデータ型は異なるが，人にとって同じ意味や機能を持つ関数を，同じ名前にすることができ，便利である．
これはオブジェクト指向プログラミング言語に広く取り入れられている考え方の一つで，{\bf ポリモルフィズム} と呼ばれている．

この機能を使うと，まったく異なる意味や機能の関数を同じ名前にすることもできる．
つまり，混乱やミスを誘発するような使い方もできるので，注意が必要である．

\EXERCISE{
先に作ったプログラムをあわせて，2次元ベクトル型と2次正方行列型の双方を使うプログラムを作れ．
このとき，加算や減算の関数が，同じ名前でもコンパイルでき，正しく動作することを確かめよ．

}


\section{C++言語らしい入出力をする}

C言語では，データの型を反映したフォーマットつきの出力や入力を \verb+printf+ 系の関数，\verb+scanf+ 系の関数で行うことが多い．
これらの関数は便利であるが，引数の数や型が自由であり，コンパイル時に完全なチェックが行われない．
そのため，実行時エラーの原因になりやすく，また悪意のあるユーザーが，プログラマが意図しないプログラムを実行させることのできる``セキュリティ・ホール''の原因になることがある．

C++言語では伝統的な \verb+printf+ 等の入出力関数のほかに，``ストリーム''とよばれるファイルの入出力の体系をライブラリで備えており，コンソールなどの標準入出力やファイルの入出力において，データや変数の型および個数をはっきりさせたプログラムを書くことができる．

C++ のストリーム標準入出力を使う場合は，専用のヘッダ（インクルード）ファイル \verb+iostream+ の利用を宣言する必要がある．
これは，C の \verb+stdio.h+ にあたる．

変数 \verb+var1+ と \verb+var2+ をメッセージ（\verb+"+ \verb+"+ でくくられた文字の配列）と共にコンソールへ出力するには，たとえば以下のようにプログラムする．
\begin{verbatim}
    std::cout << "message: " << var1 << ", another message: " 
          << var2 << "\n";
\end{verbatim}
最後の文字は，ここでは改行記号として用いている\footnotetext{実際は，OS 等によって異なる改行記号を使い分けるため，定義済みの文字定数 \verb+std::endl+ を使う方が好ましい．}．

言語に用意されている型は，自由に \verb+<<+ の引数に使うことができる．
さらに，自分で定義したクラスについても，呼び出される関数を自分で定義すれば，既存の型とまったく同様に使用することができる．
その方法は，Java 言語で \verb+toString()+ 関数を用意しておくのと同様のしくみを使うが，この演習での説明の範囲を超える（演算子，およびフレンド関数の宣言）ため，別の機会に譲ることにする．

\section{クラスで集合を表す}

集合は数学の重要な基礎概念であると同時に，
その実現方法はプログラミングの重要な基礎でもある．
ここでは，トランプのカードを例にクラスによる集合の実現を扱う．

\subsection{トランプの手は集合である}

まず，カード1枚を表すためのデータ型を考えよう．
トランプのカードには，スペード $\spadesuit$，
ダイヤモンド $\diamondsuit$，ハート $\heartsuit$，
クラブ $\clubsuit$ の 4 つのスート
\footnote{タロットではそれぞれ剣，コイン (またはペンタクル)，カップ，ワ
ンド (木杖) にあたり，アリストテレスの四元素説の 風，土，水，火 を表す．}があり，
それぞれのスートにエース (A)，2 から 10 までの字札，
そして Jack (J)，Queen (Q)，King (K) のコートカード (絵札) の
計 13 枚がある．
ここでは，さらに 1 枚ジョーカー (道化師) Joker を加え，
計53枚のセットとする．

ここでは，カードのスート (suit) と番号 (number) を別々のメンバ変数として
持つトランプカード型 \verb+Card+ を考える．
\begin{quote}
\linesparpage{50}
\begin{verbatim}
class Card {
// メンバ変数
private:
        int suit;       // 組
        int number;     // 番号
// メンバ関数
public:
        ...
};
\end{verbatim}
\end{quote}
なお，\verb+suit+ の値とスペード，ダイアモンド等との具体的な対応は，
\verb+enum+ によってつける．

次に，一人のプレーヤの「手」の表現方法を考える．
これは，トランプカードの集合であると考えられる．
ここでは集合の実現に配列を用いる\footnote{
いわゆる線形リストのようなヒープメモリを用いる (動的な) 集合の表現は，今回は扱わない．}．
\begin{quote}
\linesparpage{50}
\begin{verbatim}
class CardSet {
// メンバ変数
// 定義・宣言
public:
        const int maxnumcard = 53;      // カード総数
private:
        int numcard;            // 現在の集合内のカード数
        Card cdat[maxnumcard];  // カードのデータ
// メンバ関数
	...
};
\end{verbatim}
\end{quote}
カードのデータは配列 \verb+cdat+ に入る．
また \verb+numcard+ の値が10であれば，実際にカードのデータが納められてい
るのは配列 \verb+cdat+ の添字が 0 〜 9 までの範囲とする．
ここでは，トランプを1デッキしか使わないことを仮定しているので，
配列は長さ53あれば十分である．
この 53 という決まった数をプログラムで参照するのに，C 言語では
\verb+#define+ コンパイラ指令を利用して，マクロとして名前をつけていた．
C++ では，\verb+const+ 指定をして値を変更できない変数，すなわち定数とし
て宣言し，利用する．

\EXERCISE{
トランプカード型およびトランプカードの集合型のソースファイルが
\verb+cardset.h+ および \verb+cardset.cc+ として，
またそれを使った簡単な主プログラムが \verb+cardsetex1.cc+ として，
それぞれ用意されている．
以下の演習を実施せよ．

\begin{enumerate}

\item[(1)] プログラムをコンパイルし，実際に動くことを確かめよ．

\item[(2)] クラス \verb+CardSet+ のメンバ関数 \verb+remove()+ (2種類あり)
を実装して \verb+cardset.cc+ に追加し，
また，\verb+cardsetex1.cc+の主プログラムにカード削除のテストを追加し，
動作を確認せよ．

\end{enumerate}

}

%C++ ではコンストラクタや \verb+CardSet+ クラスの \verb+remove( )+ 関数の
%ように，同じ名前で異なる引数の関数を定義できる．
%このように同じ名前で異なる関数を定義できる機構を {\bf ポリモルフィズム} という．

\section{クラスをもとにより大きなクラスを作る}

次に，具体的なトランプゲームをもとに，ゲームの状態を表すクラスを考える．
ここでは，いわゆる「ババ抜き」\footnote{もとは $\clubsuit$ の Queen
(Argine) を抜いて行う Old maid というゲームで，
Joker は日本でトランプに追加されたものだという．}
を取り上げる．
ババ抜きでは，各プレーヤの持ち手 (持ち札) がゲームの状態を表すと
考えられる．
この演習では，既にカードの集合型を実現しているので，
それを利用することを考えると，ババ抜きゲームの状態を表す型は以下のように
なる．
\begin{quote}
\linesparpage{50}
\begin{verbatim}
class BabaState {
// 定義・宣言
public:
        const int numplayer = 5;        // プレーヤ数
// メンバ変数
private:
        CardSet hand[numplayer];  // 各プレーヤの持ち手
// メンバ関数
        ...
};
\end{verbatim}
\end{quote}

ゲームの状態は，最初に全員にカードが配られた後は，あるプレーヤが別のプレー
ヤのカードを取り，
必要なら番号が一致する2枚のカードを捨てることによってのみ遷移する．
ここでは，前者をコンストラクタまたは関数 \verb+reset()+ で，
後者を関数 \verb+move()+ で実現しよう．

\EXERCISE{
ババ抜きの状態型のソースファイルが，
\verb+babastate.h+および\verb+babastate.cc+として，
またそれを使った簡単なババ抜きプログラムが
\verb+babanuki1.cc+として，それぞれ用意されている．
以下の演習を実施せよ．

\begin{enumerate}

\item[(1)] \verb+BabaState::move()+は実現されていない．
これを実現し，プログラムをコンパイルし，動作を確かめよ．

\end{enumerate}

}

\section{習うより慣れよ}

以下の4つの課題のうち，1つを選んで取り組め．

\EXERCISE{
\verb+babanuki1.cc+の主プログラムでは，
カードは自動的に選ばれるため，現状では人間が関与する場面がない．
自分が他のプレーヤのカードを取るさいは，
例えば (列の中の) 順番を指定する等して，
実際のゲームのように，人間が関与できるように変更し，実行せよ．
}

\EXERCISE{
ここまで，\verb+Card+クラスは，\verb+suit+と\verb+number+という
二つの整数をメンバ変数に用いて実現してきた．
しかし，例えば，0〜12はスペードの1〜13, 13〜25はダイヤモンドの1〜13
などと決めてやれば，一つの整数でも実現できる．

\verb+CardSet+クラスやメインプログラムに影響を与えることなく，
\verb+Card+クラスの実現方法を変更し実行せよ．
}

\EXERCISE{
ババ抜きの状態を表すクラス \verb+BabaState+ を別の実現方法で実現せよ．
例えば，長さ53の配列にそれぞれのカードの持ち主を記録しておく方法でも
状態を表すことはできる．
}

\EXERCISE{
自分の好きなゲームを取り上げ，そのゲームの状態を表すクラスを実現せよ．
また，簡単な主プログラムを作り，そのクラスが適切に作られていることを確認せよ．
}

\section*{◆レポートの形式内容と提出方法}

\begin{enumerate}
 \item A4 のレポート用紙を用い，上部をステープラでとめること．
 \item 表紙には，
演習名 (知能情報工学実験演習 I--2\ C++演習)，
名前，学生番号，実験日，班名，レポート提出日を明記すること．
 \item 以下の内容を明確に示すこと．
 \begin{enumerate}
  \item 演習ごとの
  \begin{enumerate}
   \item (演習10の場合は)取り上げたゲームの説明
   \item プログラムのリスト
(ただし，最初に与えられたファイルそのままの場合
および前の演習と重複する場合は省略可)
   \item (演習7〜10の場合は)(主な)関数の実現の考え方
(工夫した点および不完全な点を含む)
   \item 考察あるいはこの演習で理解した点
  \end{enumerate}
  \item 全体の考察および感想
 \end{enumerate}
%\item 考察では可能であれば次のようなテーマについて考えてみよ．
 \item レポートは，このテーマの実験最終日の\underline{翌週の金曜日}の%翌週の金曜日}の
16 時 30 分から 17 時の間に，
研究棟 7 階の山本教官のもとまで提出すること．
なお，提出時に演習の内容について簡単な質問を行なうことがある．
内容を理解していないと思われる場合は
レポートを受理しないので注意すること．
\end{enumerate}

\end{document}

\begin{quote}
\linesparpage{50}
\begin{verbatim}

\end{verbatim}
\end{quote}

\begin{quote}
\linesparpage{50}
\begin{verbatim}

\end{verbatim}
\end{quote}

\begin{quote}
\linesparpage{50}
\begin{verbatim}

\end{verbatim}
\end{quote}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%###########%%%


\EXERCISE{

1セットのトランプのカード(これをデッキという)でゲームすることを考える．
ここでは，1デッキには1枚のジョーカーを含む53枚のカードがあるとする．

1デッキ内のカードの部分集合を表す型
(これは1人のプレーヤーの手持ちのカードの集合や捨てカードの集合を表す)
を作れ．

}

\begin{enumerate}

 \item[(1)] カード1枚を表すデータ型を作る(作り方いろいろ)．

 \item[(2)] カードの集合(手持ちのカード)を表す型を作る．
(ただし，使用しているカードは1組とする．(同じカードは1枚しかない．)
(下薗先生案をちょっと変更．
実現方法いろいろ: 配列，線形リスト，ビット表現，木...
それぞれどんな長所短所があるかを考えさせる)

\end{enumerate}

\POINT{ポインタとポインタ引数の説明}{}

\POINT{ヒープとスタックの説明}{}

\section{C++言語で型を作る}

\subsection{C言語には抽象データ型を作りにくいところがある}

＃下薗先生の説明

\subsection{演習3}

\begin{enumerate}

 \item[(1)] 演習1の分数の型をクラスを使って書きかえよ．

\end{enumerate}

\subsection{演習4}

\begin{enumerate}

 \item[(1)] 演習2のカードの集合を表す型をクラスにせよ．
主プログラムを作り確認せよ．

 \item[(2)] 演習2のカードの集合を表すクラスの実現を変えよ．
同じ主プログラムで動くか．動かないとしたら何が原因か．

\end{enumerate}

\section{クラスをもとにより大きなクラスを作る}

\subsection{クラスのメンバ変数にクラスを含めればより大きいクラスが作れる}

分数の実数部，仮数部を持つ虚数クラスの実現

\subsection{演習5}

\begin{enumerate}

 \item[(1)] 虚数クラスを完成させなさい．

\end{enumerate}

\subsection{演習6}

\begin{enumerate}

 \item[(1)] 演習4のカードの集合クラスを用いて，
「ババ抜き」の全プレーヤの状態を表すクラスを作りなさい．
(どんな操作が必要か?)

\end{enumerate}

\section{習うより慣れろ}

\subsection{演習6}

\begin{enumerate}

 \item[(1)] 自分の好きな(カード?)ゲームの状態を表すクラスを作りなさい．
適当な主プログラムを作り，(少なくとも)電子ゲーム盤を作りなさい．
余力のある人は，簡単な思考ルーチンを作ってもよい．

\end{enumerate}

\section{ここで扱っていない大事なこと}

\begin{itemize}

 \item 型の間の関係の表し方(1対1，1対多，多対多)

 \item クラスの継承

 \item 演算子の再定義

 \item ...

\end{itemize}

\end{document}


・型とは何か

・抽象データ型

・データ構造は型の実現方法である

・問題に対していきなりベタで変数を書くのではない．
問題の規模に応じた(十分大きな，処理が書き易い)型を作るのが先決．

・型を実現するのに必要なことは，(1)一つのデータを一つにまとめる，(2)一つのデータをまとめて操作できること．

・一つのデータを一つにまとめるには，(Cでは)構造体を用いる．

・ヒープとスタック
・ポインタとポインタ引数

Cでの演習 (card)

・まとめて操作させる上で，Cの構造体は不便である

・情報隠蔽とポリモルフィズムの必要性

C++の説明と演習 (card)

・型を組み合わせてより大きな型を作る

・1対1

・1対多

・多対多

・冗長なデータはまとめてポインタで指す

\end{document}

「文書は人のためならず」という．

