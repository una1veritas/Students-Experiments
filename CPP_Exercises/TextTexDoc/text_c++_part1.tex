%#!platex
%%#!jlatex209
%
% 知能情報工学実験演習 I (2) C++演習 テキスト
% text02a.tex - 04/10/08 版 - 下薗＆乃万
%
%¥documentstyle[11pt]{j-article}
¥documentstyle[11pt,a4,epsf]{jarticle}
%¥usepackage{amssymb}
%¥input{A4}
¥setlength{¥topmargin}{-1cm}
¥setlength{¥oddsidemargin}{0cm}
¥setlength{¥textwidth}{16cm}
¥setlength{¥textheight}{24cm}
¥renewcommand{¥@}[1]{{¥bf #1}}
¥title{{¥normalsize 知能情報工学実験演習 II } ¥¥
¥bf C++演習 (Part 1)} 
 ¥author{担当: 中村貞吾・下薗真一 (TA: 原田/井上)  ¥¥
E-mail: ¥footnotesize
{¥sf ¥{teigo, m¥_harada¥}@dumbo.ai.kyutech.ac.jp},¥¥
¥footnotesize
{¥sf sin@ai.kyutech.ac.jp},¥¥
¥footnotesize
{¥sf t¥_inoue@pluto.ai.kyutech.ac.jp}}%¥date{第1.0.3版 ¥ 2004 年 10 月}
¥date{}
%
% 諸定義
%
¥def¥linesparpage#1{¥baselineskip=¥textheight¥divide¥baselineskip#1}
%%%%% 演習問題の表示 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
¥newcounter{execnumber}
¥setcounter{execnumber}{0}
¥newcommand{¥EXERCISE}[1]{
 %¥medskip
 ¥refstepcounter{execnumber}
 ¥begin{center}
  ¥fbox{
   ¥begin{minipage}{¥textwidth}
    ¥noindent
    {¥bf 演習 ¥arabic{execnumber}}
    #1
   ¥end{minipage}
  }
 ¥end{center}
 %¥medskip
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% ワンポイントの表示 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
¥newcounter{pntnumber}
¥setcounter{pntnumber}{0}
¥newcommand{¥POINT}[2]{
 ¥medskip
 ¥refstepcounter{pntnumber}
¥noindent
■■■■■ {¥sf Point ¥arabic{pntnumber}:} {¥bf #1} ¥hrulefill ■ ¥¥
{¥small #2}

¥noindent
■ ¥hrulefill ■■■■■ ¥¥
% ¥begin{center}
%  ¥fbox{
%   ¥begin{minipage}{¥textwidth}
%    ¥noindent
%    {¥bf ポイント ¥arabic{pntnumber} (#1)}
%    #2
%   ¥end{minipage}
%  }
% ¥end{center}
 ¥medskip
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% 本文
%
¥begin{document}
%¥linesparpage{40}
¥linesparpage{36}
¥maketitle

¥medskip

¥begin{description}
¥item[期間:] 第 3 年次前期
¥item[機材:] CAD実験室(共通教育研究棟 3 階 S303 室)の Linux PC 端末%¥¥
%	初回のみ 第 I 計算機室(研究棟 6 階)の Linux PC 端末
¥item[注意:] 実験は Part 1 の 3 回 と Part 2 の 3 回，計 6 回に分けて行うが，
実験・演習に割り当てられている時間以外でも，
自由に計算機を使用してかまわない．
研究棟側の端末でも実験は可能である．	¥¥
¥underline{Part 1 では実験は個人単位で行ない，各人別々にプログラムを作成すること}．
¥end{description}

¥medskip

¥section{演習の目標}

C 言語および C++ 言語を使うプログラミングをしながら，
実用的なプログラムを作るときに必要なプログラミング作法，つまり読
みやすくミスの生じにくいプログラムの書き方を身につける．
またその中で，構造化プログラミングと，その発展形であるオブジェクト指向プログ
ラミングの理解を深め，その一部を活用できるようになることを目標とする．

一言でいえば，初心者プログラミングからの卒業が目標である．
まずその指針を簡単に挙げておく．

¥subsection{同じことなら単純なものほどよい（オッカムの剃刃）}

プログラムを書くとき，あまり深く考えず，とりあえず必要そうな変数を
%¥verb+int+とか¥verb+double+など単純な既存の型で
山のように宣言するのをよく見かける．
その結果，使わない変数や値を与えない引数があっても気にしないでいる．
もしそうなら，今日からやめること．

プログラムをなぜ書くのか．
それは，プログラムに盛り込まれる規則，知識，アイディアを，
プログラムの共同開発者，プログラムの利用者など，他の人と共有するためである．
他の人と共有するためには，客観的な基準で整理整頓されている必要があり，
そして単純簡潔であることが，整理整頓を容易に実現する最も有効な方法なのである．

¥subsection{まず``データ型''から作る}

整数型や文字型，つまりバイトやワードなどCPUが直接操作できる型だけで
実用プログラムを作ることは，組み込みマイコンのプログラムなどをのぞけば，めったにない．
たいていプログラムの作成は，人間にとって意味のあるデータの単位を
プログラムで扱う「型」として表現することからはじめる．
実はこの作業が，プログラムに行わせる作業をきれいに整理しよく理解するための，つまり問題解決の鍵である．

C/C++は，構造体もしくはクラスという仕組みでデータ構造とその操作を
はっきり対応させたプログラムを書くことができる言語である．
この特徴を生かしてこそプログラミング言語である．

%¥footnotetext{
%Niklaus Wirth（著名な計算機科学者．チューリング賞受賞者）の名著(の一つ)に「アルゴリズム+データ構造=プログラム」という本がある．
%操作とその対象は，常に対応させて考えなければならない．
%データ型をうまく実現する際にデータ構造を考える必要がある．
%Wirth の書名は今でも意味がある．}


¥subsection{大域変数は禁止}

大域変数はいつでもどこででも使え，引数に書かなくても関数の間でデータ受け渡しができる
ので即席プログラムには便利である．
しかし，プログラムが大きく複雑になると，変数がどこでなんのため使われているかわからなくなる．
とりわけ，オブジェクト指向プログラミングでは``大域変数を使いたい病''は大きな障害になる．

データを型として組み合わせてまとめ，使う変数を最少限にするのが，
プログラムをうまく作るコツである．
関数のデータのやり取りも，関数の動作や操作対象を単純明快にするため，引数と返り値のみで行いたい．


¥section{復習：C言語で型を作る}

¥subsection{データ型とは一定の意味を持たせたモデルと操作の組合せである}

デジタル機器では，どんなデータもビットの列で表す．
例えば，整数¥verb+1040187392+と実数¥verb+0.125F+はどちらも 32 ビットの列 
¥[
¥verb+0011 1110 0000 0000 0000 0000 0000 0000+
¥]
(¥verb+3E 00 00 00+) である．
いや実際は，アルファベット 8 文字であるかもしれないし，音楽 CD に
記録されたステレオ音声データの 1 サンプル目かもしれない．
計算機のハードウェアには，どのアドレスのデータが何型かといった情報は自分でつけないかぎり存在しない．
% C 言語の ¥verb$union$ 共用体を使えば，メモリ上の同じバイト列を異なるデータ型によみかえる
%ことをプログラム中で正しく意図的に行うことができる．
%
我々がさまざまなデータの異なる演算を使い分けられるのは，
プログラムの中で ¥verb+int+型のデータには¥verb+int+型の操作 (命令) を，
¥verb+float+型のデータには¥verb+float+型の操作を（コンパイラが）選んでいるからである．
%つまり，データの意味と型は操作で決まる．

データ型の本質は，内部表現の方法ではなく，
{¥bf モデル}(例えば数学でいう「整数」)と
{¥bf 操作}(例えば整数の加算演算)の対応関係にある．
これは，¥verb+int+型や¥verb+float+型がメモリの中でどのように表されるかを知らなくても，プログラムを書いたりできることからも明らかである．
%¥footnote{ふつうは
%自分が使っている計算機がbig-endianかlittle-endianかすら気にしない．}．
データ型がどんな内部表現か知らなくても（普通は知らない），操作がその内部表現に対応すれば使えるのだ．

C++ で構造体／クラスを使ってデータ型と関数をまとめて書けるようになっているのは，この対応を
プログラマが記述できるようにして，¥verb$+-*/$ など CPU が直接行える演算と同等に使用できるように
するためである．

%演習１


¥subsection{計算機中に存在しないものを表すのが抽象データ型}

プログラムで必要となるデータ型には様々なものがありうるので，
プログラミング言語があらかじめそのすべてを用意することはできない．
極端な話，整数や浮動小数点数ですら，桁や精度の制限があり，数学的な整数や実数を表しているわけではない．
必要なデータ型は，使える型を組み合わせて{¥bf 自分で作るもの}なのである．
これが{¥bf 抽象データ型}である．

自分で型を作るとき，以下の二つのことが必須となる．
¥begin{enumerate}

 ¥item[(1)] データ一個を表すのに必要なデータ（値）は，すべて一つにまとめる．	¥¥
既存の型でも，例えば，
浮動小数点数の符号部と指数部と仮数部は必ず一まとまりにして扱っている．
分けて見たり操作する必要はない．

 ¥item[(2)] 一個のデータは，いつもまとめて操作する．	¥¥
既存の型でも，例えば，浮動小数点数の演算をすると，
符号部も指数部も仮数部も一緒に計算される．

¥end{enumerate}
なぜなら，人間にとって，一つと考えられるものは「一つ」として扱えるほうがわかりやすく，楽で間違いがないからである．

¥subsection{データを一まとめにするには構造体を使う}

データを一まとめにするには，必要なデータを組み合わせる．
C言語では，構造体 (struct) を宣言することによって行う．
(C++言語では，構造体をクラスともよぶ．)
組み合わせに使うデータの型が言語で用意されたものか，別の抽象データ型かは問われない．

例えば，数学でいう${¥bf R}^2$の要素，2次元ベクトルを表すには，
それぞれの成分を例えば ¥verb+double+ 型で表すことにして
次のような構造体 ¥verb+vector2+ を作ればよい．
¥begin{quote}
¥linesparpage{50}
¥begin{verbatim}
struct vector2 {
        double x;       /* x値 */
        double y;       /* y値 */
};
¥end{verbatim}
¥end{quote}
もちろん，¥verb!double val[2];! のようにして，x, y の各値を配列の要素で表すこともできる．


¥subsection{データの操作は一まとめで行なう}

データには，内部表現を気にすることなく一まとまりとして扱えるよう操作を準備する．
例えば浮動小数点数の加算では，指数部や仮数部の計算は表には見えない．
同じように，抽象データ型の操作も，その型のデータそのものを扱うような関数
を準備して使う．
こうすることによって，¥underline{内部表現を変更しても操作関数を変更する
だけで済む}．

例えば，2次元ベクトルの加法演算は，
¥begin{quote}
¥linesparpage{50}
¥begin{verbatim}
struct vector2 addv2(struct vector2 u, struct vector2 v)
{
        struct vector2 ret;

        ret.x = u.x + v.x;
        ret.y = u.y + v.y;

        return ret;
}
¥end{verbatim}
¥end{quote}
と用意し，プログラムで 2次元ベクトル同士の加算が必要なら，
¥begin{quote}
¥linesparpage{50}
¥begin{verbatim}
vec0 = addv2(vec1, vec2);
¥end{verbatim}
¥end{quote}
などと書く．
操作関数を作る手間を惜しんで，いちいち
¥begin{quote}
¥linesparpage{50}
¥begin{verbatim}
vec0.x = vec1.x + vec2.x;
vec0.y = vec1.y + vec2.y;
¥end{verbatim}
¥end{quote}
などと書いていれば，かえって手間がかかるばかりでなく，後で何をしたかった
のかがわかりにくいコードになり，プログラミングを破綻させる原因になる．

¥subsection{抽象データ型は関数の作り方の指針でもある}

今までは，関数の宣言のしかたはわかっていても，
なにを一つの関数にすればよいのか，わからなかったかもしれない．
抽象データ型の考えを使えば，{¥bf あるデータ型をあつかう関数は，その型のデー
タの操作として意味のある関数にする}
という，関数の作り方の指針が明確になる．

プログラムを作る際は，組み込みの型から小さな型を，
小さな型から大きな型を作っていく．
同様に，関数もデータに必要な操作ごとに，小さな型のための関数を組み合わせ
大きな型のための関数を作ってゆく．
こうすることで抽象度の高いレベルで処理を簡潔に記述でき，
自然ときれいな ------ つまり読みやすくミスの起きにくい ------
プログラムが書けるのである．

¥EXERCISE{
(C言語による) 2次元ベクトル型のソースファイルが，
¥verb+vector2c.h+ および ¥verb+vector2c.c+ として，
またそれを使った簡単な主プログラムが ¥verb+vec2ex1c.c+ として，
それぞれ用意されている．以下の演習を実施せよ．

¥begin{enumerate}

¥item[(1)] プログラムをコンパイルし，実際に動くことを確かめよ．

¥item[(2)] 減算の関数を ¥verb+vector2c.h+ および ¥verb+vector2c.c+ に
追加し，また，¥verb+vec2ex1c.c+ の主プログラムに減算のテストを追加し，
実際に動くことを確かめよ．

%%% 検討: 内積の関数
%%% 検討: 引数をポインタ型に変える演習

¥end{enumerate}

}

%演習３

ソースファイルの構成法とコンパイル¥leaders¥hbox{---}¥hfill¥kern0pt %¥hrulefill
¥begin{quote}

C や C++ では，原則として，以下のようにソースファイルを分割する．

¥begin{enumerate}

 ¥item[(a)] {¥bf ヘッダファイル}	¥¥
定数，型の定義(具体的には，構造体(や C++ のクラス)の定義になる)，
関数のプロトタイプ宣言を，名前が¥verb+.h+で終るファイルにまとめる．
これを，ヘッダファイルという．
ヘッダファイルは，関連する型(1つの場合もある)ごとにまとめる．

 ¥item[(b)] {¥bf プログラムファイル}	¥¥
C や C++ の関数の処理を記述するファイルをプログラムファイルという．
プログラムファイル名は，C 言語では ¥verb+.c+で，
C++ 言語では ¥verb+.cc+，¥verb|.c++|，¥verb+.cpp+ などで終るようにする．
プログラムファイルの先頭では {¥tt ¥#include}で必要なヘッダファイルを
インクルードする．

プログラムファイルは，例えば，それぞれの型毎に1つずつにわけ，
特定のアプリケーションの主プログラムなども，型とは別のファイルにする．
このようにすると，例えば上の例では，
2次元ベクトルを用いた主プログラムを変更しても，
2次元ベクトルの加算，減算などの関数のファイルには影響がないことになる．

¥end{enumerate}

複数のソースファイルから成るプログラムをコンパイルするには，	¥¥
¥hspace*{10mm}{¥tt ¥% cc vector2c.c vec2ex1c.c}	¥¥
¥hspace*{10mm}{¥tt ¥% c++ vector2p.cc vec2ex1p.cc}	¥¥
のように，必要なソースファイル名を並べればよい．
また，¥¥
¥hspace*{10mm}{¥tt ¥% cc -c vector2c.c}	¥¥
¥hspace*{10mm}{¥tt ¥% cc -c vec2ex1c.c}	¥¥
のように，個々のファイル毎にコンパイルしておき，後で，	¥¥
¥hspace*{10mm}{¥tt ¥% cc vector2c.o vec2ex1c.o}	¥¥
のようにリンクだけ行なうこともできる．
これを{¥bf 分割コンパイル}という．
¥end{quote}
¥hrulefill

¥newpage
¥section{C++言語で型を作る}

¥subsection{C言語での型作りの弱点}

前節のように，C言語でも抽象データ型を作ることはできるが，
ソースコードがもっと複雑で大規模になった場合,
あるいは複数のプログラマで分担して作業するような場合に，
次のような問題や不都合が生じる．

¥begin{enumerate}
 ¥item[(1)] 
構造体 ¥verb+vector2+ のメンバ変数に，どのような状況でも直接アクセスができる．
逆に，メンバ変数の値を直接変更した場合，なにが起きるか予想できない．
プログラマの心がけに任せるばかりでなく，
むしろ積極的に，たとえば ¥verb+vector2+ をベクトルとして利用する部分では
¥begin{quote}
¥linesparpage{50}
¥begin{verbatim}
vec0.x = vec1.x + 2 * vec2.x;
¥end{verbatim}
¥end{quote}
のような，ベクトルとしての意味がはっきりしないメンバ変数の直接操作はできないようにしたい．
 ¥item[(2)] 
加算には，2次元ベクトルの加算だけでなく，3次元ベクトルや行列の加算もある．
それらは「加算」という意味では同じであるが，引数の型が異なるため¥verb+addv2+，¥verb+addv3+，
¥verb+addmatrix+ など，それぞれ別の関数名を付ける必要があり，命名と利用の両面で煩わしい．
¥item[(3)] 
変数の宣言や動的割り付けを行った直後に，その変数の各メンバ変数の値がどうなっている
のか，あるいはどうする必要があるのかがプログラムからはっきりしない．
初期値が 0 や ¥verb+NULL+ なのか，あるいは不定なのかはコンパイラや環
境にも依存する．
メンバ変数に抽象データ型が使用され入れ子になっている場合，どこまで初期値の面倒をみれば
いいのかも不明であり，めんどうである．
¥end{enumerate}


¥subsection{C++言語ではクラスによって型作りが楽になる}

C++ では，こののような問題を解決するために{¥bf クラス}というデータ型定義
の機構が提供されている．
クラス ¥verb+class+ は，C言語の構造体 ¥verb+struct+ を拡張したもので，「データを一まとめにする」機能に加え，
初期化や操作，アクセスなどそのデータに必要な関数も一まとめにすることができ，またそのデータの内部，つまりメンバ変数や関数へ外からアクセスできるかどうかの制御もできる
¥footnote{実は C++ では構造体 {¥tt struct} も関数を持てるよう拡張されていて，その違い
は情報隠蔽を明示的に行うか否かの違いだけである．}．
これは{¥bf データと手続きのカプセル化 encapsulation}と呼ばれ，
オブジェクト指向プログラミングでの考え方の一つである．
また，変数の宣言や動的領域の確保など，変数が用意される時，初期化の関数を指示しなければデフォルトの初期化関数が自動的に呼び出される．
必要な初期化が必ず行われるようにできるのである．
これも，オブジェクト指向プログラミングでの考え方の一つである．

2次元ベクトル型をクラスで表現すると以下のようになる．
¥begin{quote}
¥linesparpage{50}
¥begin{verbatim}
class Vector2 {
// メンバ変数
private:
        double x;       // x値
        double y;       // y値
// メンバ関数
public:
        Vector2(void)   { }
                // デフォルトコンストラクタ(初期値不定)
        Vector2(double x0, double y0);
                // x0, y0 を与えて定数 (x0, y0) を得るコンストラクタ
        Vector2 add(Vector2 u);
                // 自身のベクトルとベクトル u との和を求める
        ....
};
¥end{verbatim}
¥end{quote}
このように，メンバ変数と同様に，その型専用の関数も記述できるのである．

クラスでのメンバ変数の宣言は，構造体での宣言と同じである．
ただし，アクセス指定子 ¥verb+private:+ によって，メンバ変数 ¥verb+x+と
¥verb+y+ をこのクラスのメンバ関数 (後述) だけがアクセスできる
「プライベート (私的) な」変数とすることができる．
これにより，メンバ変数が知らないうちに --- 
つまりクラスの定義以外の場所で --- 変更されるプログラムが書かれてしまう心配がなくなる．

データのクラスにそなわるメンバ関数を呼び出すときは，構造体のメンバ変数と同様に，変数に ¥verb+.+ で結び付けた形で記述する．
例えば，
¥begin{quote}
¥linesparpage{50}
¥begin{verbatim}
Vector2 v1, v2, v3;
...
v3 = v1.add(v2);
¥end{verbatim}
¥end{quote}
という形で呼び出す．
これは，C言語の場合には，
¥begin{quote}
¥linesparpage{50}
¥begin{verbatim}
v3 = addv2(v1, v2);
¥end{verbatim}
¥end{quote}
のように書いていたプログラムに相当する．

クラス内で宣言したメンバ関数の実体は，例えば次のようにプログラムする．
¥begin{quote}
¥linesparpage{50}
¥begin{verbatim}
Vector2 Vector2::add(Vector2 u)
{
        Vector2 ret;

        ret.x = x + u.x;
        ret.y = y + u.y;

        return ret;
}
¥end{verbatim}
¥end{quote}
ここで，ただの ¥verb+x+ と ¥verb+y+ は¥footnote{実際には「このデータ (オ
 ブジェクト)」のポインタを表す ¥verb+this+ を使って ¥verb+this->x+ と ¥verb+this->y+
 と書くところで，¥verb+this+ が省略されている．}
 ¥verb+add+ 関数を呼び出した（作用する）変数のメンバ変数，つ
まり ¥verb+v1.add(v2)+ では ¥verb+v1+ のメンバ変数 ¥verb+v1.x+,
¥verb+v1.y+ を指す．

上の例では，メンバ関数はアクセス指定子 ¥verb+public:+ によって外部から使
うことができる「公開された」関数になっている．
メンバ変数，メンバ関数は，
それぞれ ¥verb+private:+ (そのクラス以外からはアクセス不可能)，
あるいは ¥verb+public:+ (そのクラス以外からもアクセス可能) にできる．
メンバ変数を ¥verb+private:+ に，
メンバ関数を ¥verb+public:+ にするのが典型的である．


¥subsection{C++言語では変数の初期化をはっきり型に書く}

クラス名と同じ関数名のメンバ関数は，{¥bf コンストラクタ}と呼ぶ．
コンストラクタはそのクラス（型）の変数の場所をメモリ上に確保するときに呼び出され，その変数が持つメンバ変数の値を設定する．
その返り値は，そのクラス型のデータ (オブジェクト) と決まっているので，返値は記述しない．
変数の初期化し忘れを防ぐために，コンストラクタは必ず呼び出されることになっ
ている．
コンストラクタは引数を持つこともでき，初期化に使う値を引数で指定したり，他の型のデータを初期化に使うものも作成できる．
引数の無いコンストラクタは変数宣言などの際に暗黙のうちに呼び出され
るので，特に {¥bf デフォルトコンストラクタ} と呼ばれる．

コンストラクタは，変数宣言などプログラマが意識して行う場合のほかにも，
代入 ¥verb+=+ や型変換 (タイプ・キャスト) で気づかないうちに呼び出されることもあるため，プログラムのミスの原因になることがある¥footnote{Smalltalk (Squeak) や Java などの言語ではクラス型データはポインタなど
間接参照が基本なので目立たないが，C/C++ では構造体の代入や引数での値参照
が可能なので，注意が必要である．}．
代入やコピーで呼び出されるコンストラクタは{¥bf コピーコンストラクタ}とよ
ばれ，引数は同じクラスのデータへの参照 ¥verb+&+ 一つのみである．
C++ プログラミングでのミスを減らすには，自分で作るクラスにはデフォルトコ
ンストラクタ，コピーコンストラクタはとりあえず作っておく習慣をつけるとよい．

¥EXERCISE{
(C++言語による) 2次元ベクトル型のソースファイルが，
¥verb+vector2p.h+および¥verb+vector2p.cc+として，
またそれを使った簡単な主プログラムが¥verb+vec2ex1p.cc+として，
それぞれ用意されている．以下の演習を実施せよ．

¥begin{enumerate}

¥item[(1)] プログラムをコンパイルし，実際に動くことを確かめよ．

¥item[(2)] クラス ¥verb+Vector2+ の減算のメンバ関数を
¥verb+vector2p.h+ および ¥verb+vector2p.cc+ に追加し，
また，¥verb+vec2ex1p.c+ の主プログラムに減算のテストを追加し，
減算が行われることを確かめよ．

%%% 検討: 内積の関数
%%% 検討: 引数をポインタ型に変える演習

¥end{enumerate}

}

¥EXERCISE{
コンストラクタが明示的に，また暗黙の内に選択的に呼び出されることを以下の
方法で確かめよ．
¥begin{enumerate}
¥item[(1)] 
デフォルトコンストラクタ ¥verb+Vector2(void)+ で，¥verb+x+ と ¥verb+y+
に初期値 ¥verb+0+ がセットされるよう変更し，¥verb+printf+ 等で変数宣言な
	   どの直後に初期化されているかどうかを確かめよ．
¥item[(2)] 
デフォルトコンストラクタと，コンストラクタ
¥verb+Vector2(double, double)+ の中で ¥verb+printf+ 等でメッセージの印字
を行うようにして，適切なコンストラクタが呼び出されているかどうかの確認をせ
よ．
¥item[(3)]
値のセットされた ¥verb+Vector2+ 型オブジェクトと全く同じ ¥verb+x+ および
¥verb+y+ 成分の値を持つオブジェクトとして初期化するコピーコンストラクタ 
¥verb/ public: Vector2(Vector2 ¥& v)/ 
を宣言し，(2) と同様に呼び出されているかどうかの確認をできるようにして，プログラム中で
¥verb+Vector2+ 型変数への代入を行い確かめよ．
¥end{enumerate}

}

¥EXERCISE{
2次元ベクトル型を参考にして，2次正方行列型をクラスとして実現せよ．
また，簡単な主プログラムを作成し，実際に動くことを確認せよ．

2次正方行列型は，少なくとも，入力，出力，加算，減算，乗算の
各メンバ関数を持つようにせよ．
なお，クラスの実現には，$2 ¥times 2$の2次元配列を用いればよい．

}


¥subsection{C++では関数の引数の型や数が関数名の一部である}

コンストラクタは，すべてクラス名と同じである．
コンストラクタ以外にも，C++言語では，対象となるクラス（型）や引数，またその数が異なれば，異なる関数に同じ名前を付けることができる．
この機能を正しく使うと，例えば次元の異なるベクトルの加算のように，扱うデータ型は異なるが，人にとって同じ意味や機能を持つ関数を，同じ名前にすることができ，便利である．
これはオブジェクト指向プログラミング言語に広く取り入れられている考え方の一つで，{¥bf ポリモルフィズム} と呼ばれている．

この機能を使うと，まったく異なる意味や機能の関数を同じ名前にすることもできる．
つまり，混乱やミスを誘発するような使い方もできるので，注意が必要である．

¥EXERCISE{
先に作ったプログラムをあわせて，2次元ベクトル型と2次正方行列型の双方を使うプログラムを作れ．
このとき，加算や減算の関数が，同じ名前でもコンパイルでき，正しく動作することを確かめよ．
}

%C++io

¥section{クラスで集合を表す}

集合は数学の重要な基礎概念であると同時に，
その実現方法はプログラミングの重要な基礎でもある．
ここでは，トランプのカードを例にクラスによる集合の実現を扱う．

¥subsection{トランプの手は集合である}

まず，カード1枚を表すためのデータ型を考えよう．
トランプのカードには，スペード $¥spadesuit$，
ダイヤモンド $¥diamondsuit$，ハート $¥heartsuit$，
クラブ $¥clubsuit$ の 4 つのスート
¥footnote{タロットではそれぞれ剣，コイン (またはペンタクル)，カップ，ワ
ンド (木杖) にあたり，アリストテレスの四元素説の 風，土，水，火 を表す．}があり，
それぞれのスートにエース (A)，2 から 10 までの字札，
そして Jack (J)，Queen (Q)，King (K) のコートカード (絵札) の
計 13 枚がある．
ここでは，さらに 1 枚ジョーカー (道化師) Joker を加え，
計53枚のセットとする．

ここでは，カードのスート (suit) と番号 (number) を別々のメンバ変数として
持つトランプカード型 ¥verb+Card+ を考える．
¥begin{quote}
¥linesparpage{50}
¥begin{verbatim}
class Card {
// メンバ変数
private:
        int suit;       // 組
        int number;     // 番号
// メンバ関数
public:
        ...
};
¥end{verbatim}
¥end{quote}
なお，¥verb+suit+ の値とスペード，ダイアモンド等との具体的な対応は，
¥verb+enum+ によってつける．

次に，一人のプレーヤの「手」の表現方法を考える．
これは，トランプカードの集合であると考えられる．
ここでは集合の実現に配列を用いる¥footnote{
いわゆる線形リストのようなヒープメモリを用いる (動的な) 集合の表現は，今回は扱わない．}．
¥begin{quote}
¥linesparpage{50}
¥begin{verbatim}
class CardSet {
// メンバ変数
// 定義・宣言
public:
        const int maxnumcard = 53;      // カード総数
private:
        int numcard;            // 現在の集合内のカード数
        Card cdat[maxnumcard];  // カードのデータ
// メンバ関数
	...
};
¥end{verbatim}
¥end{quote}
カードのデータは配列 ¥verb+cdat+ に入る．
また ¥verb+numcard+ の値が10であれば，実際にカードのデータが納められてい
るのは配列 ¥verb+cdat+ の添字が 0 〜 9 までの範囲とする．
ここでは，トランプを1デッキしか使わないことを仮定しているので，
配列は長さ53あれば十分である．
この 53 という決まった数をプログラムで参照するのに，C 言語では
¥verb+#define+ コンパイラ指令を利用して，マクロとして名前をつけていた．
C++ では，¥verb+const+ 指定をして値を変更できない変数，すなわち定数とし
て宣言し，利用する．

¥EXERCISE{
トランプカード型およびトランプカードの集合型のソースファイルが
¥verb+cardset.h+ および ¥verb+cardset.cc+ として，
またそれを使った簡単な主プログラムが ¥verb+cardsetex1.cc+ として，
それぞれ用意されている．
以下の演習を実施せよ．

¥begin{enumerate}

¥item[(1)] プログラムをコンパイルし，実際に動くことを確かめよ．

¥item[(2)] クラス ¥verb+CardSet+ のメンバ関数 ¥verb+remove()+ (2種類あり)
を実装して ¥verb+cardset.cc+ に追加し，
また，¥verb+cardsetex1.cc+の主プログラムにカード削除のテストを追加し，
動作を確認せよ．

¥end{enumerate}

}

%C++ ではコンストラクタや ¥verb+CardSet+ クラスの ¥verb+remove( )+ 関数の
%ように，同じ名前で異なる引数の関数を定義できる．
%このように同じ名前で異なる関数を定義できる機構を {¥bf ポリモルフィズム} という．

¥section{クラスをもとにより大きなクラスを作る}

次に，具体的なトランプゲームをもとに，ゲームの状態を表すクラスを考える．
ここでは，いわゆる「ババ抜き」¥footnote{もとは $¥clubsuit$ の Queen
(Argine) を抜いて行う Old maid というゲームで，
Joker は日本でトランプに追加されたものだという．}
を取り上げる．
ババ抜きでは，各プレーヤの持ち手 (持ち札) がゲームの状態を表すと
考えられる．
この演習では，既にカードの集合型を実現しているので，
それを利用することを考えると，ババ抜きゲームの状態を表す型は以下のように
なる．
¥begin{quote}
¥linesparpage{50}
¥begin{verbatim}
class BabaState {
// 定義・宣言
public:
        const int numplayer = 5;        // プレーヤ数
// メンバ変数
private:
        CardSet hand[numplayer];  // 各プレーヤの持ち手
// メンバ関数
        ...
};
¥end{verbatim}
¥end{quote}

ゲームの状態は，最初に全員にカードが配られた後は，あるプレーヤが別のプレー
ヤのカードを取り，
必要なら番号が一致する2枚のカードを捨てることによってのみ遷移する．
ここでは，前者をコンストラクタまたは関数 ¥verb+reset()+ で，
後者を関数 ¥verb+move()+ で実現しよう．

¥EXERCISE{
ババ抜きの状態を表現するための型がソースファイル
¥verb+babastate.h+および¥verb+babastate.cc+に，
またそれを使った簡単なババ抜きプログラムが
¥verb+babanuki1.cc+として，それぞれ用意されている．
以下の演習を実施せよ．

¥begin{enumerate}

¥item[(1)] ¥verb+BabaState::move()+は実現されていない．
これを実現し，プログラムをコンパイルし，動作を確かめよ．

¥end{enumerate}

}

¥section{習うより慣れよ}

以下の3つの課題のうち，1つを選んで取り組め¥footnote{無論，すべてを実装することを妨げない．}．
%¥EXERCISE{
%¥verb+babanuki1.cc+の主プログラムでは，
%カードは自動的に選ばれるため，現状では人間が関与する場面がない．
%自分が他のプレーヤのカードを取るさいは，
%例えば (列の中の) 順番を指定する等して，
%実際のゲームのように，人間が関与できるように変更し，実行せよ．
%}

¥EXERCISE{
ここまで，¥verb+Card+クラスは，¥verb+suit+と¥verb+number+という
二つの整数をメンバ変数に用いて実現してきた．
しかし，例えば，0〜12はスペードの1〜13, 13〜25はダイヤモンドの1〜13
などと決めてやれば，一つの整数でも実現できる．

¥verb+CardSet+クラスやメインプログラムに影響を与えることなく，
¥verb+Card+クラスの実現方法を変更し実行せよ．
}

¥EXERCISE{
ババ抜きの状態を表すクラス ¥verb+BabaState+ を別の実現方法で実現せよ．
例えば，長さ53の配列にそれぞれのカードの持ち主を記録しておく方法でも
状態を表すことはできる．
}

%¥input{自由演習の部分とか．発展課題とか．}

¥section*{◆レポートの形式内容と提出方法}

¥begin{enumerate}
 ¥item A4 のレポート用紙を用い，上部をステープラでとめること．
 ¥item 表紙には，
演習名 (知能情報工学実験演習 II¥ C++演習)，
名前，学生番号，実験日，班名，レポート提出日を明記すること．
 ¥item 以下の内容を明確に示すこと．
 ¥begin{enumerate}
  ¥item 演習ごとの
  ¥begin{enumerate}
   ¥item (自由演習については)設定した課題の説明
   ¥item プログラムのリスト
(ただし，最初に与えられたファイルそのままの場合
および前の演習と重複する場合は省略可)
   ¥item (演習11以降の場合は)(主な)関数の実現の考え方
(工夫した点および不完全な点を含む)
   ¥item 考察あるいはこの演習で理解した点
  ¥end{enumerate}
  ¥item 全体の考察¥footnote{感想ではなく考察をすること．「面白かった．」や「難しかった．」だけではダメ．}とまとめ
 ¥end{enumerate}
%¥item 考察では可能であれば次のようなテーマについて考えてみよ．
 ¥item レポートは，このテーマの実験最終日の翌週の同一曜日までに，
研究棟 7 階(E706)の嶋田のもとまで提出すること．
レポートは評価され，不備のあるものは〆切から1週間以内に知能の掲示板に再レポートの掲示をするので，注意しておくこと．
¥end{enumerate}

¥end{document}

¥begin{quote}
¥linesparpage{50}
¥begin{verbatim}

¥end{verbatim}
¥end{quote}

¥begin{quote}
¥linesparpage{50}
¥begin{verbatim}

¥end{verbatim}
¥end{quote}

¥begin{quote}
¥linesparpage{50}
¥begin{verbatim}

¥end{verbatim}
¥end{quote}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%###########%%%


¥EXERCISE{

1セットのトランプのカード(これをデッキという)でゲームすることを考える．
ここでは，1デッキには1枚のジョーカーを含む53枚のカードがあるとする．

1デッキ内のカードの部分集合を表す型
(これは1人のプレーヤーの手持ちのカードの集合や捨てカードの集合を表す)
を作れ．

}

¥begin{enumerate}

 ¥item[(1)] カード1枚を表すデータ型を作る(作り方いろいろ)．

 ¥item[(2)] カードの集合(手持ちのカード)を表す型を作る．
(ただし，使用しているカードは1組とする．(同じカードは1枚しかない．)
(下薗先生案をちょっと変更．
実現方法いろいろ: 配列，線形リスト，ビット表現，木...
それぞれどんな長所短所があるかを考えさせる)

¥end{enumerate}

¥POINT{ポインタとポインタ引数の説明}{}

¥POINT{ヒープとスタックの説明}{}

¥section{C++言語で型を作る}

¥subsection{C言語には抽象データ型を作りにくいところがある}

＃下薗先生の説明

¥subsection{演習3}

¥begin{enumerate}

 ¥item[(1)] 演習1の分数の型をクラスを使って書きかえよ．

¥end{enumerate}

¥subsection{演習4}

¥begin{enumerate}

 ¥item[(1)] 演習2のカードの集合を表す型をクラスにせよ．
主プログラムを作り確認せよ．

 ¥item[(2)] 演習2のカードの集合を表すクラスの実現を変えよ．
同じ主プログラムで動くか．動かないとしたら何が原因か．

¥end{enumerate}

¥section{クラスをもとにより大きなクラスを作る}

¥subsection{クラスのメンバ変数にクラスを含めればより大きいクラスが作れる}

分数の実数部，仮数部を持つ虚数クラスの実現

¥subsection{演習5}

¥begin{enumerate}

 ¥item[(1)] 虚数クラスを完成させなさい．

¥end{enumerate}

¥subsection{演習6}

¥begin{enumerate}

 ¥item[(1)] 演習4のカードの集合クラスを用いて，
「ババ抜き」の全プレーヤの状態を表すクラスを作りなさい．
(どんな操作が必要か?)

¥end{enumerate}

¥section{習うより慣れろ}

¥subsection{演習6}

¥begin{enumerate}

 ¥item[(1)] 自分の好きな(カード?)ゲームの状態を表すクラスを作りなさい．
適当な主プログラムを作り，(少なくとも)電子ゲーム盤を作りなさい．
余力のある人は，簡単な思考ルーチンを作ってもよい．

¥end{enumerate}

¥section{ここで扱っていない大事なこと}

¥begin{itemize}

 ¥item 型の間の関係の表し方(1対1，1対多，多対多)

 ¥item クラスの継承

 ¥item 演算子の再定義

 ¥item ...

¥end{itemize}

¥end{document}


・型とは何か

・抽象データ型

・データ構造は型の実現方法である

・問題に対していきなりベタで変数を書くのではない．
問題の規模に応じた(十分大きな，処理が書き易い)型を作るのが先決．

・型を実現するのに必要なことは，(1)一つのデータを一つにまとめる，(2)一つのデータをまとめて操作できること．

・一つのデータを一つにまとめるには，(Cでは)構造体を用いる．

・ヒープとスタック
・ポインタとポインタ引数

Cでの演習 (card)

・まとめて操作させる上で，Cの構造体は不便である

・情報隠蔽とポリモルフィズムの必要性

C++の説明と演習 (card)

・型を組み合わせてより大きな型を作る

・1対1

・1対多

・多対多

・冗長なデータはまとめてポインタで指す

¥end{document}

「文書は人のためならず」という．

